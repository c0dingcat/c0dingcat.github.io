<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c0dingcat</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>daily log</description>
    <pubDate>Wed, 07 Mar 2018 02:49:50 -0800</pubDate>
    
      <item>
        <title>2개의 정렬된 Array에서 교차점 찾기</title>
        <link>/2018/03/05/find-intersection.html</link>
        <guid isPermaLink="true">/2018/03/05/find-intersection.html</guid>
        <description>&lt;h2 id=&quot;2개의-정렬된-array에서-교차점-찾기&quot;&gt;2개의 정렬된 Array에서 교차점 찾기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;그냥 무식하게 찾으면 O(m*n)&lt;/li&gt;
  &lt;li&gt;아래 방식으로 하면 최대 O(m+n)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; findIntersection(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {
  vector&amp;lt;int&amp;gt; intersection;
  int n1 = A.size();
  int n2 = B.size();
  int i = 0, j = 0;
  while (i &amp;lt; n1 &amp;amp;&amp;amp; j &amp;lt; n2) {
    if (A[i] &amp;gt; B[j]) {
      j++;
    } else if (B[j] &amp;gt; A[i]) {
      i++;
    } else {
      intersection.push_back(A[i]);
      i++;
      j++;
    }
  }
  return intersection;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>QuickSelect</title>
        <link>/2018/03/05/QuickSelect.html</link>
        <guid isPermaLink="true">/2018/03/05/QuickSelect.html</guid>
        <description>&lt;h2 id=&quot;quickselect&quot;&gt;QuickSelect&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Two sorted array of size size n each. Find the Kth largest element in these two array&lt;/li&gt;
  &lt;li&gt;http://leetcode.com/2011/01/find-k-th-smallest-element-in-union-of.html&lt;/li&gt;
  &lt;li&gt;http://stackoverflow.com/questions/5000512/find-the-top-k-sums-of-two-sorted-arrays&lt;/li&gt;
  &lt;li&gt;The best solution, but non-trivial, O(lg m + lg n):&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct input {
    vector&amp;lt;int&amp;gt; source;
    int spos;
    int epos;
    int getSize() {
        return epos-spos+1;
    }
    static int pivotPos(const input&amp;amp; s1, const input&amp;amp; s2, int k) {
        return (int)((double)s1.getSize() / (s1.getSize()+s2.getSize()) * (k-1));
    }
    void getLeftRight(int pivot_pos, int&amp;amp; left, int&amp;amp; right){
        if(pivot_pos == 0)
            left = INT_MIN;
        else
            left = source[pivot_pos-1];
        if(pivot_pos == epos)
            right = INT_MIN;
        else
            right = source[pivot_pos];
    }
}

int findKthSmallest(input&amp;amp; s1, input&amp;amp; s2, int k){

  int s1_pivot_pos = input.pivotPos(s1,s2,k);
  int s2_pivot_pos = (k-1) - s1_pivot_pos;
 
  int s1_left, s1_right;
  s1.getLeftRight(s1_left, s1_right);

  int s2_left, s2_right;
  s2.getLeftRight(s2_left, s2_right);
 
  if (s2_left &amp;lt; s1_right &amp;amp;&amp;amp; s1_right &amp;lt; s2_right)
    return s1_right;
  else if (s1_left &amp;lt; s2_right &amp;amp;&amp;amp; s2_right &amp;lt; s1_right)
    return s2_right;
 
  if (s1_right &amp;lt; s2_right){
    return findKthSmallest(
        s1.left += s1_pivot_pos + 1;
        s1.right -= s1_pivot_pos -1;
        s2.right = s2_pivot_pos;
        s1, 
        s2, 
        k-s1_pivot_pos-1);
  }
  else{
      s1.right = s1_pivot_pos;
      s2.left += s2_pivot_pos+1;
      s2.right -= s2_pivot_pos-1;
    return findKthSmallest(
        s1, 
        s2, 
        k-s2_pivot_pos-1);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>펜윅트리 - 빠르고 간단한 구간 합</title>
        <link>/2018/03/04/%ED%8E%9C%EC%9C%85%ED%8A%B8%EB%A6%AC.html</link>
        <guid isPermaLink="true">/2018/03/04/%ED%8E%9C%EC%9C%85%ED%8A%B8%EB%A6%AC.html</guid>
        <description>&lt;h2 id=&quot;펜윅트리-fenwick&quot;&gt;펜윅트리 (Fenwick)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/fenwick.png&quot; alt=&quot;풴윅트리&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;구간합을 구하는데 특화된 간략화된 segement tree&lt;/li&gt;
  &lt;li&gt;segment tree가 미리 계사해 저장하는 정보의 상당수가 필요 없게됨&lt;/li&gt;
  &lt;li&gt;http://www.crocus.co.kr/666 설명 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using namespace std;
int sum(vector&amp;lt;int&amp;gt; &amp;amp;tree, int i) {
    int ans = 0;
    while (i &amp;gt; 0) {
        ans += tree[i];
        i -= (i &amp;amp; -i);
    }
    return ans;
}
void update(vector&amp;lt;int&amp;gt; &amp;amp;tree, int i, int diff) {
    while (i &amp;lt; tree.size()) {
        tree[i] += diff;
        i += (i &amp;amp; -i);
    }
}
int main() {
    int n, m, k;
    scanf(&quot;%d %d %d&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);
    vector&amp;lt;int&amp;gt; a(n+1);
    vector&amp;lt;int&amp;gt; tree(n+1);
    for (int i=1; i&amp;lt;=n; i++) {
        scanf(&quot;%lld&quot;,&amp;amp;a[i]);
        update(tree, i, a[i]);
    }
    m += k;
    while (m--) {
        int t1;
        scanf(&quot;%d&quot;,&amp;amp;t1);
        if (t1 == 1) {
            int t2;
            int t3;
            scanf(&quot;%d %d&quot;,&amp;amp;t2,&amp;amp;t3);
            int diff = t3-a[t2];
            a[t2] = t3;
            update(tree, t2, diff);
        } else {
            int t2,t3;
            scanf(&quot;%d %d&quot;,&amp;amp;t2,&amp;amp;t3);
            printf(&quot;%d\n&quot;,sum(tree, t3) - sum(tree, t2-1));
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>접미사 배열 - 맨버-마이너스 알고리즘</title>
        <link>/2018/03/04/%EC%A0%91%EB%AF%B8%EC%82%AC-%EB%B0%B0%EC%97%B4-%EB%A7%A8%EB%B2%84-%EB%A7%88%EC%9D%B4%EC%96%B4%EC%8A%A4.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%A0%91%EB%AF%B8%EC%82%AC-%EB%B0%B0%EC%97%B4-%EB%A7%A8%EB%B2%84-%EB%A7%88%EC%9D%B4%EC%96%B4%EC%8A%A4.html</guid>
        <description>&lt;h2 id=&quot;접미사-배열&quot;&gt;접미사 배열&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;접미사 배열의 길이는 항상 H이므로 문자열 탐색 시에 접미사 배열 내부의 아이템을 찾는 시간은 logH, 문자열 검색에 N&lt;/li&gt;
  &lt;li&gt;그래서 시간 복잡도는 O(NlogH)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;접미사-배열-생성---단순한-알고리즘&quot;&gt;접미사 배열 생성 - 단순한 알고리즘&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    struct comparator {
        const string&amp;amp; source;
        comparator(const string&amp;amp; s):source(s){}
        bool operator()(int i, int j) {
            return strcmp(source.c_str()+1, source.c_str() + j) &amp;lt; 0 ;
        }
    }

    vector&amp;lt;int&amp;gt; getSuffixArray(const string &amp;amp; source){
        vector&amp;lt;int&amp;gt; output;
        for(int i = 0 ; i &amp;lt; source.size(); i++) {
            output.push_back(i);
        }
        sort(output.begin(), output.end(), comparator(source));
        return output;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;시간복잡도: 문자열 비교에 N, 정렬에 NlogN, 시간복잡도: O(N&lt;sup&gt;2&lt;/sup&gt;logN)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;맨버-마이어스-알고리즘&quot;&gt;맨버-마이어스 알고리즘&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;접미사 목록을 여러번에 걸쳐서 정렬&lt;/li&gt;
  &lt;li&gt;처음에는 한글자 기준, 다음에는 두 글자 기준, .. 등등으로 여러번에 걸쳐서 정렬함&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>외계 신호 분석 - 온라인 알고리즘</title>
        <link>/2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제해결 전력 19.6 - 외계신호 분석&lt;/li&gt;
  &lt;li&gt;신호 생성 방식 A[0] = 1983, A[i] = (A[i-1]*214013+2531011) mod 2&lt;sup&gt;32&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;슬라이딩 윈도우 기법으로 한꺼번에 많은 메모리를 할당하지 않고, 바로 합이 k가 되는 숫자들을 구하고 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct asig {
    unsigned seed;
    asig():seed(1983){}
    unsinged next() {
        unsigned ret = seed;
        seed = ((seed*214013u)+2531011u);
        return ret % 1000 + 1;
    }
}

int countRanges(int k, int n) {
    asig sig_;
    queue&amp;lt;int&amp;gt; range;
    int ret = 0, rangeSum = 0;
    for(int i = 0 ;  i &amp;lt; n ; i++) {
        int new_sig = sig_.next();
        rangeSum += new_sig;
        range.push(new_sig);

        while(rangeSum &amp;gt;k){
            rangeSum -= range.front(); range.pop();
        }
        if(rangeSum == k) ret++;
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>소방차</title>
        <link>/2018/03/04/%EC%86%8C%EB%B0%A9%EC%B0%A8.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%86%8C%EB%B0%A9%EC%B0%A8.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;서울 시내에 m개의 소방서가 있습니다.&lt;/li&gt;
  &lt;li&gt;화재 장소에서 가장 가까운 소방서에서 소방차를 보낸다고 할 때, 각 화재 장소에 소방차가 도달하기까지 걸리는 시간의 합을 계산하는 프로그램을 작성하세요
&lt;img src=&quot;/assets/img/fire_trucks.png&quot; alt=&quot;소방서&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;“예제 지도를 봅시다. 사각형으로 표시된 지점들은 소방서를, 음영으로 칠해진 지점들은 불이 난 지점을 나타냅니다. 2번과 5번 장소에서는 6번 소방서가 가장 가깝고, 3번 장소에서는 4번 소방서가 가장 가깝습니다. 이때, 각 장소에 소방차가 도착하기까지 걸리는 시간은 2번 장소에 8분, 5번 장소에 4분, 3번 장소에 4분으로 총 합은 16분이 됩니다.” 예제 설명 발췌 - https://algospot.com/judge/problem/read/FIRETRUCKS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;풀이법&quot;&gt;풀이법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다익스트라를 돌릴때 시작점을 여러개로 두면 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct edge {
    double cost;
    int u;
    edge(double c, int u_):cost(c),u(u_){}
    edge(){}
};

struct {
    bool operator()(const edge&amp;amp; lhs, const edge&amp;amp; rhs){
        return lhs.cost &amp;gt; rhs.cost;
    }
} op_comp;

void dijstra(const map&amp;lt;int, vector&amp;lt;edge&amp;gt;&amp;gt;&amp;amp; source, const vector&amp;lt;int&amp;gt;&amp;amp; input) {
    vector&amp;lt;int&amp;gt; dists(source.size(), MAX_VALUE);
    vector&amp;lt;int&amp;gt; from(source.size(), -1);
    priority_queue&amp;lt;edge, vector&amp;lt;edge&amp;gt;, op_comp&amp;gt; que;
    
    for(int i = 0 ; i &amp;lt; input.size(); i++){
        from[i] = i;
        edge e(0.00, i);
        que.push_back(e);
    }
    
    while(!que.empty()) {
        edge e1 = que.top(); que.pop();
        
        double cost1 = e1.cost;
        
        for(int i = 0 ; i &amp;lt; source[e1.u].size(); i++) {
            edge e2 = source[e1.u][i];
            double cost2 = e2.cost;
            if(dists[e2.u] &amp;gt; (cost1+cost2)) {
                dists[e2.u] = costs1 + costs2;
                from[e2.u] = from[e1.u];
                que.push(e2);
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>정렬 알고리즘</title>
        <link>/2018/03/04/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC.html</guid>
        <description>&lt;h2 id=&quot;선택정렬-selection-sort&quot;&gt;선택정렬 (Selection Sort)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/Selection-Sort-Animation.gif&quot; alt=&quot;선택정렬&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;앞에서부터 가장 작은 수를 찾아 전체를 순환해서 위치를 교환한다&lt;/li&gt;
  &lt;li&gt;비교횟수: N + N-1 + N-2 … N*(N-1)/2&lt;/li&gt;
  &lt;li&gt;데이터 교환 횟수: N (inplace교환이기 떄문에 요소가 많은 경우에 좋다)&lt;/li&gt;
  &lt;li&gt;추가 공간 필요 없음&lt;/li&gt;
  &lt;li&gt;안정성 없음&lt;/li&gt;
  &lt;li&gt;Worst case: 역순배열&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;삽입정렬-insertion-sort&quot;&gt;삽입정렬 (Insertion Sort)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/Insertion-sort.png&quot; alt=&quot;삽입정렬&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이미 정렬된 배열에서 효과적임&lt;/li&gt;
  &lt;li&gt;Worst case: 역순배열 O(N&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
  &lt;li&gt;정렬된 배열에 대해서는 O(N)&lt;/li&gt;
  &lt;li&gt;안정성 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;퀵소트&quot;&gt;퀵소트&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/quicksort_animation.gif&quot; alt=&quot;퀵소트&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void pivot(vector&amp;lt;int&amp;gt;&amp;amp; input, int&amp;amp; lp, int&amp;amp; rp) {
    int pvt = input[(lp + rp)/2];
    do {
        while(input[lp] &amp;lt; pvt) lp++;
        while(input[rp] &amp;gt; pvt) rp--;
        if(lp &amp;lt; rp){
            swap(input[lp], input[rp]);
            lp++;
            rp--;
        }
    }while(lp &amp;lt;= rp);
}

void qsort(vector&amp;lt;int&amp;gt;&amp;amp; input, int left, int right) {
    int lp = left, rp = right;
    
    pivot(input,lp,rp);
    
    if(rp &amp;gt; left)
        qsort(input, left, rp);
    
    if(lp &amp;lt; right)
        qsort(input, lp, right);
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;합병정렬-merge-sort&quot;&gt;합병정렬 (Merge Sort)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/merge-sort-animation.gif&quot; alt=&quot;합병정렬&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;O(N):&lt;/li&gt;
  &lt;li&gt;Stability: Yes&lt;/li&gt;
  &lt;li&gt;Space Complexity: O(N) additional space required&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>비대칭 타일링</title>
        <link>/2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/asymtiling.jpg&quot; alt=&quot;비대칭타일링&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;타일링 문제 + 대칭 타일링을 제외하는 경우의 수 탐색&lt;/li&gt;
  &lt;li&gt;대칭 타일링 방법을 전체 경우에서 제외 혹은 비대칭 타일링 방법을 직접 카운트&lt;/li&gt;
  &lt;li&gt;n이 짝수인 경우와 홀수인 경우 대칭으로 타일링이 될 수 있는 경우의 수를 제거&lt;/li&gt;
  &lt;li&gt;책 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = tiling(width);
    ret = (ret - tiling(width/2) + MOD) % MOD;
    ret = (ret - tiling(width/2-1) + MOD) % MOD;
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Knapsack problem</title>
        <link>/2018/03/04/%EB%8F%99%EC%A0%84%EB%B0%94%EA%BE%B8%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%8F%99%EC%A0%84%EB%B0%94%EA%BE%B8%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법
 &lt;img src=&quot;/assets/img/knapsack.png&quot; alt=&quot;부피 및 절박도&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>우물을 기어 오르는 달팽이</title>
        <link>/2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;깊이가 n인 우물이 있고, 우물의 맨 밑바닥에는 달팽이가 있다&lt;/li&gt;
  &lt;li&gt;맑은 날에는 2미터를 기어 올라갈 수 있지만, 비가 내리면 1미터를 올라갈 수 있음&lt;/li&gt;
  &lt;li&gt;비올 확률이 50%일때, m일 안에 달팽이가 우물 끝까지 올라갈 수 있는 확률&lt;/li&gt;
  &lt;li&gt;점화식 climb(n) = f(n+1,2) + f(n+1,1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct snail {
    int n,m;
    int vector&amp;lt;map&amp;lt;int,int&amp;gt;&amp;gt;&amp;amp; cache;
    int climb(int days, int climbed) {
        if(days &amp;gt;= m) return climbed &amp;gt;= n ? 1 : 0;
        int&amp;amp; ret = cache[days][climbed];
        if(ret != -1) return ret;
        return ret = climb(days+1, climbed +2) + climb(days+1, climbed+1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>나무 자르기</title>
        <link>/2018/03/04/%EB%82%98%EB%AC%B4%EC%9E%90%EB%A5%B4%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%82%98%EB%AC%B4%EC%9E%90%EB%A5%B4%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a rod of length n inches and an array of prices that contains prices of all pieces of size smaller than n. Determine the maximum value obtainable by cutting up the rod and selling the pieces. For example, if length of the rod is 8 and the values of different pieces are given as following, then the maximum obtainable value is 22 (by cutting in two pieces of lengths 2 and 6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;주어진 제약조건에 따라 나무를 자를때 얻을 수 있는 최대 값
&lt;img src=&quot;/assets/img/cut-a-rod.png&quot; alt=&quot;나무 길이 및 가격&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;이전의 max 가치와 현재 가격을 빼고 계산했을의 가치를 서로 비교해서 최대 값을 반환한다 - knapsack문제와 동일함
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int cutRod(vector&amp;lt;int&amp;gt;&amp;amp; cache, int price[], int n)
{
   if (n &amp;lt;= 0)
     return 0;

   int max_val = INT_MIN;
   int&amp;amp; ret = cache[n];
   if(ret != -1)
    return ret;
 
   // Recursively cut the rod in different pieces and compare different 
   // configurations
   for (int i = 0; i&amp;lt;n; i++)
         ret = max(ret, price[i] + cutRod(price, n-i-1));
 
   return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>그래프</title>
        <link>/2018/03/04/%EA%B7%B8%EB%9E%98%ED%94%84.html</link>
        <guid isPermaLink="true">/2018/03/04/%EA%B7%B8%EB%9E%98%ED%94%84.html</guid>
        <description>&lt;h2 id=&quot;그래프&quot;&gt;그래프&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;무향 그래프&lt;/li&gt;
  &lt;li&gt;방향 그래프 혹은 유향 그래프&lt;/li&gt;
  &lt;li&gt;가중치 그래프&lt;/li&gt;
  &lt;li&gt;단순 그래프&lt;/li&gt;
  &lt;li&gt;DAG (directed acyclic graph)&lt;/li&gt;
  &lt;li&gt;철도망&lt;/li&gt;
  &lt;li&gt;소셜 네트워크 분석&lt;/li&gt;
  &lt;li&gt;인터넷 전송 속도 계산&lt;/li&gt;
  &lt;li&gt;한 붓 그리기&lt;/li&gt;
  &lt;li&gt;외환 거래&lt;/li&gt;
  &lt;li&gt;할일 목록 정리 - 위상 정렬&lt;/li&gt;
  &lt;li&gt;퍼즐 - 최소한으로 타일을 움직여 15-퍼즐을 푸는 문제&lt;/li&gt;
  &lt;li&gt;게임판 덮기&lt;/li&gt;
  &lt;li&gt;회의실 배정 등등 - 만족성 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래프-표현&quot;&gt;그래프 표현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인접 리스트
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; adjacent
struct edge {
  int vertex;
  int weight;
};
vector&amp;lt;edge&amp;gt; adjacent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 행렬
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; adjacent;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 리스트 장단점
    &lt;ul&gt;
      &lt;li&gt;메모리를 적게 먹음 O(V+E)&lt;/li&gt;
      &lt;li&gt;간선 (u,v)가 존재하는지 일일히 확인이 필요&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 행렬
    &lt;ul&gt;
      &lt;li&gt;메모리를 엄청 먹음 O(V&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
      &lt;li&gt;간선 확인이 간단함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dfs&quot;&gt;DFS&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인접 리스트의 경우 시간 복잡도는 O(V+E)&lt;/li&gt;
  &lt;li&gt;인접 행렬의 경우 O(V&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;위상정렬&quot;&gt;위상정렬&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;의존성 있는 작업들이 주어질때, 어떤 순서대로 수행해야 하는지 계산해 준다&lt;/li&gt;
  &lt;li&gt;dependency graph&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오일러-서킷&quot;&gt;오일러 서킷&lt;/h2&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>구간트리 - Segment Tree</title>
        <link>/2018/03/04/%EA%B5%AC%EA%B0%84%ED%8A%B8%EB%A6%AC.html</link>
        <guid isPermaLink="true">/2018/03/04/%EA%B5%AC%EA%B0%84%ED%8A%B8%EB%A6%AC.html</guid>
        <description>&lt;h2 id=&quot;구간트리&quot;&gt;구간트리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;저장된 자료들을 적절치 전처리해 질의들을 빠르게 대답할 수 있게 해줌&lt;/li&gt;
  &lt;li&gt;그림에서 맨 위가 루트에서 표현하는 구간이고, 양쪽 아래는 루트의 두 자식노드들이 표현하는 구간
&lt;img src=&quot;/assets/img/segment-tree.png&quot; alt=&quot;구간트리&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;구간트리는 일반적으로 꽉찬 이진 트리&lt;/li&gt;
  &lt;li&gt;배열로 표현을 많이 함 - 원소의 4배 정도로 사이즈를 잡으면 메모리는 낭비되도 전체 요소들을 저장하는데 문제 없음&lt;/li&gt;
  &lt;li&gt;어떤 구간이 주어지건 답을 찾기 위해 드는 시간은 O(lgn)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구간트리의-초기화&quot;&gt;구간트리의 초기화&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 구간을 두 개로 나눠 재귀 호출한 뒤, 두 구간의 최소치중 더 작은 값을 선택해 해당 구간의 최소치를 계산한다
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RMQ {
  int n;
  vector&amp;lt;int&amp;gt; rangeMin;
  RMQ(const vector&amp;lt;int&amp;gt;&amp;amp; array) {
      n = array.size();
      rangeMin.resize(n*4);
      init(array, 0, n-1, 1);
  }

  int init(const vector&amp;lt;int&amp;gt;&amp;amp; array, int left, int right, int node) {
      if(left == right)
          return rangeMin[node] = array[left];
      int mid = (left+right)/2;
      int leftMin = init(array,left, mid, node*2);
      int rightMin = init(array,mid+1, right, node*2);
      return rangeMin[node] = min(leftMin, rightMin);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 노드에 대해 초기화가 필요하기 떄문에 초기화시의 시간복잡도는 O(N)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구간트리의-질의-처리&quot;&gt;구간트리의 질의 처리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;query(left, right, nodeLeft, nodeRight) = node&lt;/li&gt;
  &lt;li&gt;쿼리 함수 [nodeLeft, nodeRight]와 우리가 최소치를 찾기 원하는 구간 [left, right]의 교집합의 최소 원소를 반환한다&lt;/li&gt;
  &lt;li&gt;node가 표현하는 구간 [nodeLeft, nodeRight]와 최소치를 찾을 구간 [left, right]의 교집합을 구한 뒤, 그에 따라 서로 다른 값을 반환한다&lt;/li&gt;
  &lt;li&gt;교집합이 공집합인 경우: 두 구간은 겹치지 않음. 반환값 없음&lt;/li&gt;
  &lt;li&gt;교집합이 [nodeLeft,nodeRight]인 경우: [left, right]가 표현하는 집합을 완전히 포함한 경우
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RMQ {
  int query(int left, int right, int nodeLeft, int nodeRight, int node) {
      if(right &amp;lt; nodeLeft || nodeRight &amp;lt; left)
          return INT_MAX;
      if(left &amp;lt;= nodeLeft &amp;amp;&amp;amp; nodeRight &amp;lt;= right)
          return rangeMin[node];
      int mid = (nodeLeft + nodeRight)/2;
      return min(
          query(left, right, nodeLeft, mid, node*2), 
          query(left, right, mid+1, nodeRight, node*2));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;전체 시간 복잡도는 O(lg n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구간-트리의-갱신&quot;&gt;구간 트리의 갱신&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 index 위치의 값이 newValue로 바뀌었다고 할떄의 시간 복잡도 - 위치를 포함하는 구간은 트리에 O(lgn)개 있음. 따라서, O(lgN) 시간에 구간 트리를 갱신할 수 있음&lt;/li&gt;
  &lt;li&gt;갱신 과정은 query() + init()
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int update(int index, int value, int nodeLeft, int nodeRight, int node) {
      if(index &amp;lt; nodeLeft || index &amp;lt; left)
          return INT_MAX;
      if(nodeLeft == nodeRight)
          return rangeMin[node] = value;

      if(index &amp;lt;= nodeLeft &amp;amp;&amp;amp; nodeRight &amp;lt; index)
          return rangeMin[node];

      int mid = (nodeLeft + nodeRight)/2;
      return min(
          query(index, value, nodeLeft, mid, node*2), 
          query(index, value, mid+1, nodeRight, node*2));
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;정렬된-수열의-특정-구간에서-최대-출현-빈도-계산&quot;&gt;정렬된 수열의 특정 구간에서 최대 출현 빈도 계산&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;정렬된 정수 수열이 주어질때, 주어진 구간의 최대 출현 빈도를 계산하는 문제를 풀어라&lt;/li&gt;
  &lt;li&gt;A= {0,0,1,1,1,1,2,3,3,3,4} 라면 A{1}부터 A{5} 까지 가장 많이 등장하는 수는 1로 모두 네 번 등장, A[5-A[7] 범위에는 1,2,3이 모두 한번씩 출현 가장 맣이 등장하는 횟수는 1&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Knapsack problem</title>
        <link>/2018/03/04/knapsack-problem.html</link>
        <guid isPermaLink="true">/2018/03/04/knapsack-problem.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법
 &lt;img src=&quot;/assets/img/knapsack.png&quot; alt=&quot;부피 및 절박도&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;부분문제: pack(items) = 지금까지 고른 물건들의 목록이 items에 주어질 때, 남은 용량을 채워 얻을 수 있는 최대의 절박도 합&lt;/li&gt;
  &lt;li&gt;pack(capacity, item) = 캐리어에 용량이 capacity만큼 남았을 때 item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도&lt;/li&gt;
  &lt;li&gt;특정 물건을 가져가는 경우 pack(capacity - volume[item], item+1) + need[item]&lt;/li&gt;
  &lt;li&gt;해당 물건을 가져가지 않는 경우 pack(capacity, item)&lt;/li&gt;
  &lt;li&gt;절박도 = max(pack(capacity - volume[item], item+1) + need[item], pack(capacity, item))&lt;/li&gt;
  &lt;li&gt;시간 복잡도는 capacity가 0~w 범위이고, 아이템들이 0~n개가 있다고 하면 &lt;strong&gt;O(nw)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;선택된 물건들의 리스트는 pack(capacity, item) == pack(capacity, item+1) 인지의 여부로 판단할 수 있다&lt;/li&gt;
  &lt;li&gt;선택된 물건들의 리스트는 pack(capacity, item) == pack(capacity, item+1) 인지의 여부로 판단할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct knapsack {
    vector&amp;lt;item&amp;gt; items;
    map&amp;lt;int,vector&amp;lt;int&amp;gt;&amp;gt; cache;
    int pack(int capacity, int item) {
        if(item == items.size()) return 0;
        int&amp;amp; ret = cache[capacity][item];
        if(ret != -1) return ret;
        ret = pack(capacity, item+1);
        if(capacity &amp;gt;= items[item].volume)
            ret = max(ret, pack(capacity - items[item].volume, item+1)) + items[item].needs;
        return ret;
    }
    void reconstruct(int capacity, int item, vector&amp;lt;int&amp;gt;&amp;amp; selected) {
        if(item == items.size()) return ;
        if(pack(capacity, item) == pack(capacity, item+1)){
            reconstuct(capacity, item+1, selected);
        }
        else{
            items.push_back(item);
            reconstruct(capacity - items[item].volume, item+1, selected);
        }
    }
}  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>변화하는 중간 값 - Running Median</title>
        <link>/2018/03/04/Running-median.html</link>
        <guid isPermaLink="true">/2018/03/04/Running-median.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;텅빈 수열에서 시작해서 각 수가 추가될 때마다 중간 값을 계산하는 프로그램을 작성하시오&lt;/li&gt;
  &lt;li&gt;유사문제: https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최대, 최소 prority queue를 사용해서 해결 가능&lt;/li&gt;
  &lt;li&gt;최대 힙의 크기는 최소 힙의 크기와 같거나 하나 더 크다&lt;/li&gt;
  &lt;li&gt;최대 힙의 최대 원소는 초소 힙의 최소 원소보다 작거나 크다&lt;/li&gt;
  &lt;li&gt;수열의 중간 값은 항상 최대 힙의 루트에 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct runningMedian {
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt;&amp;gt; maxHeap;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;

    void addNum(int num) {
        if(maxHeap.size() == minHead.size())
            maxHeap.push(num);
        else
            minHeap.push(num);
        
        if(!minHeap.empty() &amp;amp;&amp;amp; !maxHeap.empty() &amp;amp;&amp;amp; minHeap.top() &amp;lt; maxHeap.top()) {
            int a = maxHeap.top(), b = minHeap.top();
            maxHeap.pop(); minHeap.pop();
            maxHeap.push(b);
            minHeap.push(a);
        }
    }

    int getMedian() {
        return maxHeap.top();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
  </channel>
</rss>
