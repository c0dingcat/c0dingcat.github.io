<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c0dingcat</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>daily log</description>
    <pubDate>Mon, 05 Mar 2018 02:08:46 -0800</pubDate>
    
      <item>
        <title>펜윅트리 - 빠르고 간단한 구간 합</title>
        <link>/2018/03/04/%ED%8E%9C%EC%9C%85%ED%8A%B8%EB%A6%AC.html</link>
        <guid isPermaLink="true">/2018/03/04/%ED%8E%9C%EC%9C%85%ED%8A%B8%EB%A6%AC.html</guid>
        <description>&lt;h2 id=&quot;펜윅트리-fenwick&quot;&gt;펜윅트리 (Fenwick)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/fenwick.png&quot; alt=&quot;풴윅트리&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;구간합을 구하는데 특화된 간략화된 segement tree&lt;/li&gt;
  &lt;li&gt;segment tree가 미리 계사해 저장하는 정보의 상당수가 필요 없게됨&lt;/li&gt;
  &lt;li&gt;http://www.crocus.co.kr/666 설명 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using namespace std;
int sum(vector&amp;lt;int&amp;gt; &amp;amp;tree, int i) {
    int ans = 0;
    while (i &amp;gt; 0) {
        ans += tree[i];
        i -= (i &amp;amp; -i);
    }
    return ans;
}
void update(vector&amp;lt;int&amp;gt; &amp;amp;tree, int i, int diff) {
    while (i &amp;lt; tree.size()) {
        tree[i] += diff;
        i += (i &amp;amp; -i);
    }
}
int main() {
    int n, m, k;
    scanf(&quot;%d %d %d&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;k);
    vector&amp;lt;int&amp;gt; a(n+1);
    vector&amp;lt;int&amp;gt; tree(n+1);
    for (int i=1; i&amp;lt;=n; i++) {
        scanf(&quot;%lld&quot;,&amp;amp;a[i]);
        update(tree, i, a[i]);
    }
    m += k;
    while (m--) {
        int t1;
        scanf(&quot;%d&quot;,&amp;amp;t1);
        if (t1 == 1) {
            int t2;
            int t3;
            scanf(&quot;%d %d&quot;,&amp;amp;t2,&amp;amp;t3);
            int diff = t3-a[t2];
            a[t2] = t3;
            update(tree, t2, diff);
        } else {
            int t2,t3;
            scanf(&quot;%d %d&quot;,&amp;amp;t2,&amp;amp;t3);
            printf(&quot;%d\n&quot;,sum(tree, t3) - sum(tree, t2-1));
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>접미사 배열 - 맨버-마이너스 알고리즘</title>
        <link>/2018/03/04/%EC%A0%91%EB%AF%B8%EC%82%AC-%EB%B0%B0%EC%97%B4-%EB%A7%A8%EB%B2%84-%EB%A7%88%EC%9D%B4%EC%96%B4%EC%8A%A4.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%A0%91%EB%AF%B8%EC%82%AC-%EB%B0%B0%EC%97%B4-%EB%A7%A8%EB%B2%84-%EB%A7%88%EC%9D%B4%EC%96%B4%EC%8A%A4.html</guid>
        <description>&lt;h2 id=&quot;접미사-배열&quot;&gt;접미사 배열&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;접미사 배열의 길이는 항상 H이므로 문자열 탐색 시에 접미사 배열 내부의 아이템을 찾는 시간은 logH, 문자열 검색에 N&lt;/li&gt;
  &lt;li&gt;그래서 시간 복잡도는 O(NlogH)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;접미사-배열-생성---단순한-알고리즘&quot;&gt;접미사 배열 생성 - 단순한 알고리즘&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    struct comparator {
        const string&amp;amp; source;
        comparator(const string&amp;amp; s):source(s){}
        bool operator()(int i, int j) {
            return strcmp(source.c_str()+1, source.c_str() + j) &amp;lt; 0 ;
        }
    }

    vector&amp;lt;int&amp;gt; getSuffixArray(const string &amp;amp; source){
        vector&amp;lt;int&amp;gt; output;
        for(int i = 0 ; i &amp;lt; source.size(); i++) {
            output.push_back(i);
        }
        sort(output.begin(), output.end(), comparator(source));
        return output;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;시간복잡도: 문자열 비교에 N, 정렬에 NlogN, 시간복잡도: O(N&lt;sup&gt;2&lt;/sup&gt;logN)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;맨버-마이어스-알고리즘&quot;&gt;맨버-마이어스 알고리즘&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;접미사 목록을 여러번에 걸쳐서 정렬&lt;/li&gt;
  &lt;li&gt;처음에는 한글자 기준, 다음에는 두 글자 기준, .. 등등으로 여러번에 걸쳐서 정렬함&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>외계 신호 분석 - 온라인 알고리즘</title>
        <link>/2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제해결 전력 19.6 - 외계신호 분석&lt;/li&gt;
  &lt;li&gt;신호 생성 방식 A[0] = 1983, A[i] = (A[i-1]*214013+2531011) mod 2&lt;sup&gt;32&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;슬라이딩 윈도우 기법으로 한꺼번에 많은 메모리를 할당하지 않고, 바로 합이 k가 되는 숫자들을 구하고 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct asig {
    unsigned seed;
    asig():seed(1983){}
    unsinged next() {
        unsigned ret = seed;
        seed = ((seed*214013u)+2531011u);
        return ret % 1000 + 1;
    }
}

int countRanges(int k, int n) {
    asig sig_;
    queue&amp;lt;int&amp;gt; range;
    int ret = 0, rangeSum = 0;
    for(int i = 0 ;  i &amp;lt; n ; i++) {
        int new_sig = sig_.next();
        rangeSum += new_sig;
        range.push(new_sig);

        while(rangeSum &amp;gt;k){
            rangeSum -= range.front(); range.pop();
        }
        if(rangeSum == k) ret++;
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>비대칭 타일링</title>
        <link>/2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;타일링 문제 + 대칭 타일링을 제외하 경우의 수 탐색&lt;/li&gt;
  &lt;li&gt;대칭 타일링 방법을 전체 경우에서 제외 혹은 비대칭 타일링 방법을 직접 카운트&lt;/li&gt;
  &lt;li&gt;책 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Knapsack problem</title>
        <link>/2018/03/04/%EB%8F%99%EC%A0%84%EB%B0%94%EA%BE%B8%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%8F%99%EC%A0%84%EB%B0%94%EA%BE%B8%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법
 &lt;img src=&quot;/assets/img/knapsack.png&quot; alt=&quot;부피 및 절박도&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>우물을 기어 오르는 달팽이</title>
        <link>/2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;깊이가 n인 우물이 있고, 우물의 맨 밑바닥에는 달팽이가 있다&lt;/li&gt;
  &lt;li&gt;맑은 날에는 2미터를 기어 올라갈 수 있지만, 비가 내리면 1미터를 올라갈 수 있음&lt;/li&gt;
  &lt;li&gt;비올 확률이 50%일때, m일 안에 달팽이가 우물 끝까지 올라갈 수 있는 확률&lt;/li&gt;
  &lt;li&gt;점화식 climb(n) = f(n+1,2) + f(n+1,1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct snail {
    int n,m;
    int vector&amp;lt;map&amp;lt;int,int&amp;gt;&amp;gt;&amp;amp; cache;
    int climb(int days, int climbed) {
        if(days &amp;gt;= m) return climbed &amp;gt;= n ? 1 : 0;
        int&amp;amp; ret = cache[days][climbed];
        if(ret != -1) return ret;
        return ret = climb(days+1, climbed +2) + climb(days+1, climbed+1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>나무 자르기</title>
        <link>/2018/03/04/%EB%82%98%EB%AC%B4%EC%9E%90%EB%A5%B4%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%82%98%EB%AC%B4%EC%9E%90%EB%A5%B4%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a rod of length n inches and an array of prices that contains prices of all pieces of size smaller than n. Determine the maximum value obtainable by cutting up the rod and selling the pieces. For example, if length of the rod is 8 and the values of different pieces are given as following, then the maximum obtainable value is 22 (by cutting in two pieces of lengths 2 and 6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;주어진 제약조건에 따라 나무를 자를때 얻을 수 있는 최대 값
&lt;img src=&quot;/assets/img/cut-a-rod.png&quot; alt=&quot;나무 길이 및 가격&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;이전의 max 가치와 현재 가격을 빼고 계산했을의 가치를 서로 비교해서 최대 값을 반환한다 - knapsack문제와 동일함
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int cutRod(vector&amp;lt;int&amp;gt;&amp;amp; cache, int price[], int n)
{
   if (n &amp;lt;= 0)
     return 0;

   int max_val = INT_MIN;
   int&amp;amp; ret = cache[n];
   if(ret != -1)
    return ret;
 
   // Recursively cut the rod in different pieces and compare different 
   // configurations
   for (int i = 0; i&amp;lt;n; i++)
         ret = max(ret, price[i] + cutRod(price, n-i-1));
 
   return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>그래프</title>
        <link>/2018/03/04/%EA%B7%B8%EB%9E%98%ED%94%84.html</link>
        <guid isPermaLink="true">/2018/03/04/%EA%B7%B8%EB%9E%98%ED%94%84.html</guid>
        <description>&lt;h2 id=&quot;그래프&quot;&gt;그래프&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;무향 그래프&lt;/li&gt;
  &lt;li&gt;방향 그래프 혹은 유향 그래프&lt;/li&gt;
  &lt;li&gt;가중치 그래프&lt;/li&gt;
  &lt;li&gt;단순 그래프&lt;/li&gt;
  &lt;li&gt;DAG (directed acyclic graph)&lt;/li&gt;
  &lt;li&gt;철도망&lt;/li&gt;
  &lt;li&gt;소셜 네트워크 분석&lt;/li&gt;
  &lt;li&gt;인터넷 전송 속도 계산&lt;/li&gt;
  &lt;li&gt;한 붓 그리기&lt;/li&gt;
  &lt;li&gt;외환 거래&lt;/li&gt;
  &lt;li&gt;할일 목록 정리 - 위상 정렬&lt;/li&gt;
  &lt;li&gt;퍼즐 - 최소한으로 타일을 움직여 15-퍼즐을 푸는 문제&lt;/li&gt;
  &lt;li&gt;게임판 덮기&lt;/li&gt;
  &lt;li&gt;회의실 배정 등등 - 만족성 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래프-표현&quot;&gt;그래프 표현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인접 리스트
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; adjacent
struct edge {
  int vertex;
  int weight;
};
vector&amp;lt;edge&amp;gt; adjacent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 행렬
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; adjacent;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 리스트 장단점
    &lt;ul&gt;
      &lt;li&gt;메모리를 적게 먹음 O(V+E)&lt;/li&gt;
      &lt;li&gt;간선 (u,v)가 존재하는지 일일히 확인이 필요&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 행렬
    &lt;ul&gt;
      &lt;li&gt;메모리를 엄청 먹음 O(V&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
      &lt;li&gt;간선 확인이 간단함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dfs&quot;&gt;DFS&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인접 리스트의 경우 시간 복잡도는 O(V+E)&lt;/li&gt;
  &lt;li&gt;인접 행렬의 경우 O(V&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;위상정렬&quot;&gt;위상정렬&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;의존성 있는 작업들이 주어질때, 어떤 순서대로 수행해야 하는지 계산해 준다&lt;/li&gt;
  &lt;li&gt;dependency graph&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오일러-서킷&quot;&gt;오일러 서킷&lt;/h2&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>구간트리 - Segment Tree</title>
        <link>/2018/03/04/%EA%B5%AC%EA%B0%84%ED%8A%B8%EB%A6%AC.html</link>
        <guid isPermaLink="true">/2018/03/04/%EA%B5%AC%EA%B0%84%ED%8A%B8%EB%A6%AC.html</guid>
        <description>&lt;h2 id=&quot;구간트리&quot;&gt;구간트리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;저장된 자료들을 적절치 전처리해 질의들을 빠르게 대답할 수 있게 해줌&lt;/li&gt;
  &lt;li&gt;그림에서 맨 위가 루트에서 표현하는 구간이고, 양쪽 아래는 루트의 두 자식노드들이 표현하는 구간
&lt;img src=&quot;/assets/img/segment-tree.png&quot; alt=&quot;구간트리&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;구간트리는 일반적으로 꽉찬 이진 트리&lt;/li&gt;
  &lt;li&gt;배열로 표현을 많이 함 - 원소의 4배 정도로 사이즈를 잡으면 메모리는 낭비되도 전체 요소들을 저장하는데 문제 없음&lt;/li&gt;
  &lt;li&gt;어떤 구간이 주어지건 답을 찾기 위해 드는 시간은 O(lgn)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구간트리의-초기화&quot;&gt;구간트리의 초기화&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 구간을 두 개로 나눠 재귀 호출한 뒤, 두 구간의 최소치중 더 작은 값을 선택해 해당 구간의 최소치를 계산한다
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RMQ {
  int n;
  vector&amp;lt;int&amp;gt; rangeMin;
  RMQ(const vector&amp;lt;int&amp;gt;&amp;amp; array) {
      n = array.size();
      rangeMin.resize(n*4);
      init(array, 0, n-1, 1);
  }

  int init(const vector&amp;lt;int&amp;gt;&amp;amp; array, int left, int right, int node) {
      if(left == right)
          return rangeMin[node] = array[left];
      int mid = (left+right)/2;
      int leftMin = init(array,left, mid, node*2);
      int rightMin = init(array,mid+1, right, node*2);
      return rangeMin[node] = min(leftMin, rightMin);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 노드에 대해 초기화가 필요하기 떄문에 초기화시의 시간복잡도는 O(N)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구간트리의-질의-처리&quot;&gt;구간트리의 질의 처리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;query(left, right, nodeLeft, nodeRight) = node&lt;/li&gt;
  &lt;li&gt;쿼리 함수 [nodeLeft, nodeRight]와 우리가 최소치를 찾기 원하는 구간 [left, right]의 교집합의 최소 원소를 반환한다&lt;/li&gt;
  &lt;li&gt;node가 표현하는 구간 [nodeLeft, nodeRight]와 최소치를 찾을 구간 [left, right]의 교집합을 구한 뒤, 그에 따라 서로 다른 값을 반환한다&lt;/li&gt;
  &lt;li&gt;교집합이 공집합인 경우: 두 구간은 겹치지 않음. 반환값 없음&lt;/li&gt;
  &lt;li&gt;교집합이 [nodeLeft,nodeRight]인 경우: [left, right]가 표현하는 집합을 완전히 포함한 경우
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RMQ {
  int query(int left, int right, int nodeLeft, int nodeRight, int node) {
      if(right &amp;lt; nodeLeft || nodeRight &amp;lt; left)
          return INT_MAX;
      if(left &amp;lt;= nodeLeft &amp;amp;&amp;amp; nodeRight &amp;lt;= right)
          return rangeMin[node];
      int mid = (nodeLeft + nodeRight)/2;
      return min(
          query(left, right, nodeLeft, mid, node*2), 
          query(left, right, mid+1, nodeRight, node*2));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;전체 시간 복잡도는 O(lg n)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구간-트리의-갱신&quot;&gt;구간 트리의 갱신&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 index 위치의 값이 newValue로 바뀌었다고 할떄의 시간 복잡도 - 위치를 포함하는 구간은 트리에 O(lgn)개 있음. 따라서, O(lgN) 시간에 구간 트리를 갱신할 수 있음&lt;/li&gt;
  &lt;li&gt;갱신 과정은 query() + init()
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int update(int index, int value, int nodeLeft, int nodeRight, int node) {
      if(index &amp;lt; nodeLeft || index &amp;lt; left)
          return INT_MAX;
      if(nodeLeft == nodeRight)
          return rangeMin[node] = value;

      if(index &amp;lt;= nodeLeft &amp;amp;&amp;amp; nodeRight &amp;lt; index)
          return rangeMin[node];

      int mid = (nodeLeft + nodeRight)/2;
      return min(
          query(index, value, nodeLeft, mid, node*2), 
          query(index, value, mid+1, nodeRight, node*2));
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;정렬된-수열의-특정-구간에서-최대-출현-빈도-계산&quot;&gt;정렬된 수열의 특정 구간에서 최대 출현 빈도 계산&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;정렬된 정수 수열이 주어질때, 주어진 구간의 최대 출현 빈도를 계산하는 문제를 풀어라&lt;/li&gt;
  &lt;li&gt;A= {0,0,1,1,1,1,2,3,3,3,4} 라면 A{1}부터 A{5} 까지 가장 많이 등장하는 수는 1로 모두 네 번 등장, A[5-A[7] 범위에는 1,2,3이 모두 한번씩 출현 가장 맣이 등장하는 횟수는 1&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Knapsack problem</title>
        <link>/2018/03/04/knapsack-problem.html</link>
        <guid isPermaLink="true">/2018/03/04/knapsack-problem.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법
 &lt;img src=&quot;/assets/img/knapsack.png&quot; alt=&quot;부피 및 절박도&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>변화하는 중간 값 - Running Median</title>
        <link>/2018/03/04/Running-median.html</link>
        <guid isPermaLink="true">/2018/03/04/Running-median.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;텅빈 수열에서 시작해서 각 수가 추가될 때마다 중간 값을 계산하는 프로그램을 작성하시오&lt;/li&gt;
  &lt;li&gt;유사문제: https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최대, 최소 prority queue를 사용해서 해결 가능&lt;/li&gt;
  &lt;li&gt;최대 힙의 크기는 최소 힙의 크기와 같거나 하나 더 크다&lt;/li&gt;
  &lt;li&gt;최대 힙의 최대 원소는 초소 힙의 최소 원소보다 작거나 크다&lt;/li&gt;
  &lt;li&gt;수열의 중간 값은 항상 최대 힙의 루트에 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct runningMedian {
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt;&amp;gt; maxHeap;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;

    void addNum(int num) {
        if(maxHeap.size() == minHead.size())
            maxHeap.push(num);
        else
            minHeap.push(num);
        
        if(!minHeap.empty() &amp;amp;&amp;amp; !maxHeap.empty() &amp;amp;&amp;amp; minHeap.top() &amp;lt; maxHeap.top()) {
            int a = maxHeap.top(), b = minHeap.top();
            maxHeap.pop(); minHeap.pop();
            maxHeap.push(b);
            minHeap.push(a);
        }
    }

    int getMedian() {
        return maxHeap.top();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>트리의 PreOrder, InOrder 순회로 PotOrder 알아내기</title>
        <link>/2018/03/04/PreOrder-InOrder%EB%A1%9C-PostOrder-%EC%95%8C%EC%95%84%EB%82%B4%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/04/PreOrder-InOrder%EB%A1%9C-PostOrder-%EC%95%8C%EC%95%84%EB%82%B4%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주어진 PreOrder, InOrder 순환 값으로 PostOrder 순환 값을 에측하라&lt;/li&gt;
  &lt;li&gt;트리를 주어진 순환 값으로 부터 구성하면서 PostOrder 순환을 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; slice(vector&amp;lt;int&amp;gt;&amp;amp; src, int a, int b) {
    return vector&amp;lt;int&amp;gt;(src.begin()+a, src.end()+b);
}

void postOrder(vector&amp;lt;int&amp;gt;&amp;amp; preOrder, vector&amp;lt;int&amp;gt;&amp;amp; inOrder) {
    int length = preOrder.size();
    int root = preOrder[0]; // preOrder의 제일 처음에 나오는 값이 루트이다.
    
    int left = find(inOrder.begin(), inOrder.end(), root) - inOrder.begin();
    int right = length - left - 1; // 루트 값 제외

    postOrder(slice(preOrder, 1, left+1), slice(inOrder, 0, left));
    postOrer(slice(preOrder, left+1, length), slice(inOrder, left+1, length));

    cout &amp;lt;&amp;lt; root &amp;lt;&amp;lt; ' ';    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>타일링 방법의 수 세기</title>
        <link>/2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html</link>
        <guid isPermaLink="true">/2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제설명&quot;&gt;문제설명&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/tiling1.png&quot; alt=&quot;타일링&quot; /&gt;
&lt;img src=&quot;/assets/img/tiling2.png&quot; alt=&quot;타일링&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2&lt;em&gt;n 크기의 사각형을 2&lt;/em&gt;1 크기의 타일로 채우는 방법의 수를 계산하는 문제&lt;/li&gt;
  &lt;li&gt;타일을 길게 붙이거나 (2&lt;em&gt;1) 혹은 옆으로 누워서 붙이는 경우 (2&lt;/em&gt;n)로 붙이는 경우를 생각해서 계산&lt;/li&gt;
  &lt;li&gt;즉, f(n) = f(n-1) + f(n-2)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const int mod_num = 1000000007;

int tiling(const vector&amp;lt;int&amp;gt;&amp;amp; input, int width) {
    if(width &amp;lt;=1) return 1;
    int &amp;amp; ret = cache[width];
    if(ret !=-1) return ret;
    return ret = (tiling(input, width-2) + tiling(input, width-1))%mod_num;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>원주율 외우기</title>
        <link>/2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 문제 8.7&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;원주율을 몇 만 자리까지 외우기 위해 일반적으로 쓰는 방법은 3~5글자 정도로 끓어서 외운다&lt;/li&gt;
  &lt;li&gt;주어진 숫자에 대해 최소의 난이도를 구하는 방법을 계산하시오
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;경우                  예                   난이도
모든 숫자가 같을때               ex)333,55555         1
숫자가 1씩 증가 혹은 감소         ex)23456,3210        2
두개의 숫자가 번갈아 가면서 나타날때  ex)323, 54545       4
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DP를 써서 점화식을 먼저 세운다&lt;/li&gt;
  &lt;li&gt;F(L) = min(F(L,3), F(L,4), F(L,5))&lt;/li&gt;
  &lt;li&gt;F(L,3) -&amp;gt; min(F(L,4), F(L,5), F(L,6)) + classify(L,3)&lt;/li&gt;
  &lt;li&gt;classify하는 부분은 경우에 따라 파싱하면 됨&lt;/li&gt;
  &lt;li&gt;DP의 점화식에 따른 구현을 눈여겨 보도록 하자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int classify(const string&amp;amp; input, int spos, int length) {
    /// 문자열을 끓어서 classify 해서 돌려준다
}

int memorize(const string&amp;amp; input, vector&amp;lt;int&amp;gt;&amp;amp; cache, int begin) {
    if(begin == input.size())
        return 0;
    
    int&amp;amp; ret = cache[begin];
    if(ret != -1)
        return ret;
    ret = INF;
    // 3~5글자 사이로 끓어 읽어서 최소값을 구한다
    for(int L = 3 ; L &amp;lt;= 5; ++L) {
        if(begin + L &amp;lt;= input.size()) {
            ret = min(ret,
                     memorize(input, cache, begin+L) + classify(input, begin, L));
        }
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>삼각형 위의 최대 경로 개수 세기</title>
        <link>/2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제설명&quot;&gt;문제설명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이전의 문제는 최대 경로의 합을 구했을뿐, 경로 자체는 구하지 않았다&lt;/li&gt;
  &lt;li&gt;최대 경로는 유일하지 않을 수도 있다&lt;/li&gt;
  &lt;li&gt;문제를 해결하기 위해 두 개의 다른 동적 계획법 문제를 해결&lt;/li&gt;
  &lt;li&gt;합을 먼저 구하고, 그 합을 구하는 도중에 만든 캐싱을 통해 패스를 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct triangle {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; input;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; cache;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; countCache;
    
    int path(int y, int x) {
        if(y == input.size() -1)
            return input[y][x];
        
        int&amp;amp; ret = cache[y][x];
        if(ret != -1)
            return ret;
        
        return ret = max(path(y+1,x), path(y+1,x+1))+input[y][x];
    }
    
    int count(int y, int x) {
        if(y==input.size()-1)
            return 1;
        
        int &amp;amp; ret = countCache[y][x];
        if(ret!=-1)
            return ret;
        
        if(path(y+1,x+1)&amp;gt;=path(y+1,x))
            ret += path(y+1,x+1);
        if(path(y+1,x+1)&amp;lt;=path(y+1,x))
            ret += path(y+1,x);
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
  </channel>
</rss>
