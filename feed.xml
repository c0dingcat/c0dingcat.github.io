<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c0dingcat</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>daily log</description>
    <pubDate>Sun, 04 Mar 2018 04:29:00 -0800</pubDate>
    
      <item>
        <title>외계 신호 분석 - 온라인 알고리즘</title>
        <link>/2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제해결 전력 19.6 - 외계신호 분석&lt;/li&gt;
  &lt;li&gt;신호 생성 방식 A[0] = 1983, A[i] = (A[i-1]*214013+2531011) mod 2&lt;sup&gt;32&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;슬라이딩 윈도우 기법으로 한꺼번에 많은 메모리를 할당하지 않고, 바로 합이 k가 되는 숫자들을 구하고 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct asig {
    unsigned seed;
    asig():seed(1983){}
    unsinged next() {
        unsigned ret = seed;
        seed = ((seed*214013u)+2531011u);
        return ret % 1000 + 1;
    }
}

int countRanges(int k, int n) {
    asig sig_;
    queue&amp;lt;int&amp;gt; range;
    int ret = 0, rangeSum = 0;
    for(int i = 0 ;  i &amp;lt; n ; i++) {
        int new_sig = sig_.next();
        rangeSum += new_sig;
        range.push(new_sig);

        while(rangeSum &amp;gt;k){
            rangeSum -= range.front(); range.pop();
        }
        if(rangeSum == k) ret++;
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>비대칭 타일링</title>
        <link>/2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;타일링 문제 + 대칭 타일링을 제외하 경우의 수 탐색&lt;/li&gt;
  &lt;li&gt;대칭 타일링 방법을 전체 경우에서 제외 혹은 비대칭 타일링 방법을 직접 카운트&lt;/li&gt;
  &lt;li&gt;책 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>우물을 기어 오르는 달팽이</title>
        <link>/2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html</link>
        <guid isPermaLink="true">/2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;깊이가 n인 우물이 있고, 우물의 맨 밑바닥에는 달팽이가 있다&lt;/li&gt;
  &lt;li&gt;맑은 날에는 2미터를 기어 올라갈 수 있지만, 비가 내리면 1미터를 올라갈 수 있음&lt;/li&gt;
  &lt;li&gt;비올 확률이 50%일때, m일 안에 달팽이가 우물 끝까지 올라갈 수 있는 확률&lt;/li&gt;
  &lt;li&gt;점화식 climb(n) = f(n+1,2) + f(n+1,1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct snail {
    int n,m;
    int vector&amp;lt;map&amp;lt;int,int&amp;gt;&amp;gt;&amp;amp; cache;
    int climb(int days, int climbed) {
        if(days &amp;gt;= m) return climbed &amp;gt;= n ? 1 : 0;
        int&amp;amp; ret = cache[days][climbed];
        if(ret != -1) return ret;
        return ret = climb(days+1, climbed +2) + climb(days+1, climbed+1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Knapsack problem</title>
        <link>/2018/03/04/knapsack-problem.html</link>
        <guid isPermaLink="true">/2018/03/04/knapsack-problem.html</guid>
        <description>&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법
 &lt;img src=&quot;/assets/img/knapsack.png&quot; alt=&quot;부피 및 절박도&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int asymmetric(int width) {
    if(width%2 ==1)
        return (tiling(width) - tiling(width/2) + MOD) %MOD;
    int ret = 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>타일링 방법의 수 세기</title>
        <link>/2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html</link>
        <guid isPermaLink="true">/2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제설명&quot;&gt;문제설명&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/tiling1.png&quot; alt=&quot;타일링&quot; /&gt;
&lt;img src=&quot;/assets/img/tiling2.png&quot; alt=&quot;타일링&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2&lt;em&gt;n 크기의 사각형을 2&lt;/em&gt;1 크기의 타일로 채우는 방법의 수를 계산하는 문제&lt;/li&gt;
  &lt;li&gt;타일을 길게 붙이거나 (2&lt;em&gt;1) 혹은 옆으로 누워서 붙이는 경우 (2&lt;/em&gt;n)로 붙이는 경우를 생각해서 계산&lt;/li&gt;
  &lt;li&gt;즉, f(n) = f(n-1) + f(n-2)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const int mod_num = 1000000007;

int tiling(const vector&amp;lt;int&amp;gt;&amp;amp; input, int width) {
    if(width &amp;lt;=1) return 1;
    int &amp;amp; ret = cache[width];
    if(ret !=-1) return ret;
    return ret = (tiling(input, width-2) + tiling(input, width-1))%mod_num;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>원주율 외우기</title>
        <link>/2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 문제 8.7&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;원주율을 몇 만 자리까지 외우기 위해 일반적으로 쓰는 방법은 3~5글자 정도로 끓어서 외운다&lt;/li&gt;
  &lt;li&gt;주어진 숫자에 대해 최소의 난이도를 구하는 방법을 계산하시오
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;경우                  예                   난이도
모든 숫자가 같을때               ex)333,55555         1
숫자가 1씩 증가 혹은 감소         ex)23456,3210        2
두개의 숫자가 번갈아 가면서 나타날때  ex)323, 54545       4
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DP를 써서 점화식을 먼저 세운다&lt;/li&gt;
  &lt;li&gt;F(L) = min(F(L,3), F(L,4), F(L,5))&lt;/li&gt;
  &lt;li&gt;F(L,3) -&amp;gt; min(F(L,4), F(L,5), F(L,6)) + classify(L,3)&lt;/li&gt;
  &lt;li&gt;classify하는 부분은 경우에 따라 파싱하면 됨&lt;/li&gt;
  &lt;li&gt;DP의 점화식에 따른 구현을 눈여겨 보도록 하자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int classify(const string&amp;amp; input, int spos, int length) {
    /// 문자열을 끓어서 classify 해서 돌려준다
}

int memorize(const string&amp;amp; input, vector&amp;lt;int&amp;gt;&amp;amp; cache, int begin) {
    if(begin == input.size())
        return 0;
    
    int&amp;amp; ret = cache[begin];
    if(ret != -1)
        return ret;
    ret = INF;
    // 3~5글자 사이로 끓어 읽어서 최소값을 구한다
    for(int L = 3 ; L &amp;lt;= 5; ++L) {
        if(begin + L &amp;lt;= input.size()) {
            ret = min(ret,
                     memorize(input, cache, begin+L) + classify(input, begin, L));
        }
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>삼각형 위의 최대 경로 개수 세기</title>
        <link>/2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제설명&quot;&gt;문제설명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이전의 문제는 최대 경로의 합을 구했을뿐, 경로 자체는 구하지 않았다&lt;/li&gt;
  &lt;li&gt;최대 경로는 유일하지 않을 수도 있다&lt;/li&gt;
  &lt;li&gt;문제를 해결하기 위해 두 개의 다른 동적 계획법 문제를 해결&lt;/li&gt;
  &lt;li&gt;합을 먼저 구하고, 그 합을 구하는 도중에 만든 캐싱을 통해 패스를 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct triangle {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; input;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; cache;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; countCache;
    
    int path(int y, int x) {
        if(y == input.size() -1)
            return input[y][x];
        
        int&amp;amp; ret = cache[y][x];
        if(ret != -1)
            return ret;
        
        return ret = max(path(y+1,x), path(y+1,x+1))+input[y][x];
    }
    
    int count(int y, int x) {
        if(y==input.size()-1)
            return 1;
        
        int &amp;amp; ret = countCache[y][x];
        if(ret!=-1)
            return ret;
        
        if(path(y+1,x+1)&amp;gt;=path(y+1,x))
            ret += path(y+1,x+1);
        if(path(y+1,x+1)&amp;lt;=path(y+1,x))
            ret += path(y+1,x);
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Get Max Even Sum From Tree</title>
        <link>/2018/03/03/get-max-even-sum-from-tree.html</link>
        <guid isPermaLink="true">/2018/03/03/get-max-even-sum-from-tree.html</guid>
        <description>
&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;output the maximum EVEN sum along any path&lt;/li&gt;
  &lt;li&gt;![/assets/img/maxevensum.png]&lt;/li&gt;
  &lt;li&gt;트리의 각 노드들을 더해서 최대값이자 짝수인 값을 구하기&lt;/li&gt;
  &lt;li&gt;짝수가 된다는 말에 잘 주목을 해야 할 것 같다&lt;/li&gt;
  &lt;li&gt;답이 없어서 정확하게 파악은 안되지만…&lt;/li&gt;
  &lt;li&gt;모든 경로마다의 합을 구해서 정렬을 해서 짝수를 구하는 방법이 있지만, 이건 별로 안좋아할듯&lt;/li&gt;
  &lt;li&gt;그게 아니면 짝수가 되는 경우를 확인해서 최대 값을 구하는 방법이 있을것 같다&lt;/li&gt;
  &lt;li&gt;문제가 워낙 간단하게 나와서 정확한 제약조건은 알 길이 없지만, 만약 정할 수 있다면 루트를 거쳐야 한다와 마이너스 값은 허용되지 않음 두가지 경우를 설정하고 싶다&lt;/li&gt;
  &lt;li&gt;루트를 거쳐야 한다면 루트가 홀수인 경우는 왼쪽이 홀수 아니면 오른쪽이 홀수 값을 리턴해야 한다&lt;/li&gt;
  &lt;li&gt;루트가 짝수인 경우는 왼쪽, 오른쪽 둘다 홀수 혹은 짝수가 되어야 한다&lt;/li&gt;
  &lt;li&gt;그리고 post order 방식으로 트리를 순환하고, 노도의 값을 먼저 더해서 노드의 왼쪽 오른쪽 노드의 탐색이 끝난 후에 값을 확인한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

struct node {
    int value;
    node* left, *right;
    node(int n):value(n){}
};

int oddNodeAdd(node* ptr, int total) {
    if(!ptr)
        return total;
    
    int left = oddNodeAdd(ptr-&amp;gt;left, total + ptr-&amp;gt;value);
    int right = oddNodeAdd(ptr-&amp;gt;right, total + ptr-&amp;gt;value);
    
    int ld = left % 2, rd = right % 2;
    if(ld == 1 &amp;amp;&amp;amp; rd ==1)
        return max(left, right);
    
    if(ld==1 &amp;amp;&amp;amp; rd==0)
        return ld;
    
    if(rd==1 &amp;amp;&amp;amp; ld==0) 
        return rd;
    
    return total;
}

int evenNodeAdd(node* ptr, int total) {
    
    if(!ptr)
        return 0 ;
    
    int left = evenNodeAdd(ptr-&amp;gt;left, total + ptr-&amp;gt;value);
    int right = evenNodeAdd(ptr-&amp;gt;right, total + ptr-&amp;gt;value);
    
    // 
    int ld = left %2, rd = right%2;
    
    if((ld ==0&amp;amp;&amp;amp;rd ==0)) {
        return max(left, right);
    }
    
    if(ld==1&amp;amp;&amp;amp;ld==0) {
        return rd;
    }
    
    if(ld==0&amp;amp;&amp;amp;rd==1) {
        return ld;
    }

    return total;
}

int getMaxEvenNumber(node* ptr) {
    
    int maxValue = 0 ;
    int oddLeft = oddNodeAdd(ptr-&amp;gt;left,0);
    int oddRight = oddNodeAdd(ptr-&amp;gt;right, 0);
    int evenLeft = evenNodeAdd(ptr-&amp;gt;right,0);
    int evenRight = evenNodeAdd(ptr-&amp;gt;right,0);
    
    maxValue = max(oddLeft + oddRight, evenLeft + evenRight);
    maxValue = max(maxValue, max(oddLeft+evenRight, evenLeft+oddRight));
    maxValue = maxValue + ptr-&amp;gt;value; 
    
    return maxValue;
}

int main() {
    node* ptr = new node(10);
    ptr-&amp;gt;left = new node(2);
    ptr-&amp;gt;left-&amp;gt;left = new node(1);
    ptr-&amp;gt;left-&amp;gt;right = new node(101);
    ptr-&amp;gt;right = new node(5);
    ptr-&amp;gt;right-&amp;gt;right = new node(13);  
    cout &amp;lt;&amp;lt; getMaxEvenNumber(ptr);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>KMP 알고리즘</title>
        <link>/2018/03/03/Shortest-Palindrome.html</link>
        <guid isPermaLink="true">/2018/03/03/Shortest-Palindrome.html</guid>
        <description>&lt;h2 id=&quot;shortest-palindrome&quot;&gt;Shortest Palindrome&lt;/h2&gt;

&lt;h3 id=&quot;출처&quot;&gt;출처&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://leetcode.com/problems/shortest-palindrome/description/&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문제&quot;&gt;문제&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주어진 스티링 S에 대해서 글자들을 앞부분에 더해서 회문으로 만들 수 있다. 이때, 가장 짧은 글자를 더해서 만들 수 있는 회문을 구하라.&lt;/li&gt;
  &lt;li&gt;Given “aacecaaa”, return “aaacecaaa”.
Given “abcd”, return “dcbabcd”.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분석&quot;&gt;분석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bruteforce로 할 수 있는 방법:
    &lt;ul&gt;
      &lt;li&gt;S를 reverse 해서 reversed 된 스트링의 substring과 S의 서브스트링을 비교한다.&lt;/li&gt;
      &lt;li&gt;Time complexity: O(N2)&lt;/li&gt;
      &lt;li&gt;Space complexity: O(N)
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string shortestPalindrome(string s)
{
 int n = s.size();
 string rev(s);
 reverse(rev.begin(), rev.end());
 int j = 0;
 for (int i = 0; i &amp;lt; n; i++) {
  if (s.substr(0, n - i) == rev.substr(i))
      return rev.substr(0, i) + s;
 }
 return &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KMP 방식을 사용한다
    &lt;ul&gt;
      &lt;li&gt;KMP 방식에 따라 Fail function lookup table 을 만들면 얼마만큼의 prefix가 현재까지 매칭되었는지를 알 수 있고 이 값을 사용해서 panlindrome을 만들기 위해 필요한 문자열을 알 수 있게 된다.&lt;/li&gt;
      &lt;li&gt;입력 S을 reverse한후 ‘#’ 와 함께 원래 입력에 더한다 string input = s + ‘#’ + reverse(s)&lt;/li&gt;
      &lt;li&gt;’#’은 원래 값과 reverse된 문자열이 섞이지 않도록 필요&lt;/li&gt;
      &lt;li&gt;KMP fail_function을 만들어서 surfix와 동일한 prefix의 최장 길이를 구할 수 있고 이 길이를 알면 reverse된 문자열에서 필요한 문자열을 뽑아낼 수 있다
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  string shortestPalindrome(string input) {
        
  int n = input.length();
  string rev(input);
  std::reverse(rev.begin(), rev.end());
        
  string source = input + &quot;#&quot; + rev;
  int len = source.size();   
         
  vector&amp;lt;int&amp;gt; fail_table(len, 0);
        
  for(int pos = 1; pos &amp;lt; len; pos++){
      int last_match_pos = fail_table[pos-1];
      while(last_match_pos &amp;gt; 0 
            &amp;amp;&amp;amp; source[pos] != source[last_match_pos])
          last_match_pos = fail_table[last_match_pos-1];
            
      if(source[pos] == source[last_match_pos])
          ++last_match_pos;
            
      fail_table[pos] = last_match_pos;
  } 
        
  return rev.substr(0, n - fail_table[len - 1]) + input;         
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>KMP 알고리즘</title>
        <link>/2018/03/03/KMP-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/2018/03/03/KMP-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://www.crocus.co.kr/559&lt;/li&gt;
  &lt;li&gt;http://jason9319.tistory.com/130&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kmp-알고리즘kmp-algorithm&quot;&gt;KMP 알고리즘(KMP Algorithm)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;www.crocus.co.kr&lt;/li&gt;
  &lt;li&gt;KMP 방식을 요약하면..
    &lt;ul&gt;
      &lt;li&gt;패턴의 substring을 만들어서 prefix 와 suffix가 같을때의 최장 길이를 찾는다
ex) aba =&amp;gt; 1, aabaa =&amp;gt;2, acdefa =&amp;gt; 1 ..&lt;/li&gt;
      &lt;li&gt;패턴의 substring 매칭에 대한 테이블을 만든다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/assets/img/kmp.png&quot; alt=&quot;KMP fail table&quot; /&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void fail_function(const string&amp;amp; input, vector&amp;lt;int&amp;gt;&amp;amp; output) {
  output.resize(input.size(),0);  
  int last_pos = 0;
  for(auto pos = 1; pos &amp;lt; input.size(); pos++) {
  while(last_pos &amp;gt;0 &amp;amp;&amp;amp; input[pos] != input[last_pos])
      last_pos = output[last_pos-1];
        
  if(input[pos] == input[last_pos])
      output[pos] = ++last_pos;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;source = aabaabaaaabaabaadaabaabac가 있다고 가정하자.&lt;/li&gt;
  &lt;li&gt;pattern = aabaabac를 찾으려 한다면 표를 다음과 같이 이용하면 된다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaaba[a]aabaabaadaabaabac
aabaaba[c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaaba까지 같다. 따라서 arr[i]의 7번째 인덱스에서 a와 c가 틀렸으니,aabaaba의 f[6] = 4 따라서 (7-4) = 3인 arr[3]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaa[a]abaabaadaabaabac
 aabaa[b]ac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaa까지 같다. 따라서 arr[i]의 8번째 인덱스에서 a와 b가 틀렸으니, aabaa의 f[i] = 2 따라서 (8-2) = 6인 arr[6]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaa[a]abaabaadaabaabac
　　　 aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aa까지 같다. 따라서 arr[i]의 8번째 인덱스에서 a와 b가 틀렸으니, aa의 f[i] = 1 따라서 (8-1) = 7인 arr[7]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaa[a]abaabaadaabaabac
　　　 aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aa까지 같다. 따라서 arr[i]의 9번째 인덱스에서 a와 b가 틀렸으니, aa의 f[i] = 1 따라서 (9-1) = 8인 arr[8]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaa[a]baabaadaabaabac
　　　  aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaaba까지 같다. 따라서 arr[i]의 15번째 인덱스에서 a와 c가 틀렸으니, aabaaba의 f[i] = 4 따라서 (15-4) = 11인 arr[11]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaaba[a]daabaabac
　　　　　aabaaba[c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaa까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 b가 틀렸으니, aabaa의 f[i] = 2 따라서 (16-2) = 14인 arr[14]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaa[d]aabaabac
　　　　　　 aabaa[b]ac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aa까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 b가 틀렸으니, aa의 f[i] = 1 따라서 (16-1) = 15인 arr[15]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaa[d]aabaabac
　　　　　　    aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: a까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 a가 틀렸으니, a의 f[i] = 0  따라서 (16-0) = 16인 arr[16]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaa[d]aabaabac
　　　　　　　   a[a]baabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: 같은 것이 없다. 따라서 arr[17]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaad[aabaabac]
　　　　　　　      [aabaabac]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: 모두 일치. 정답을 도출한다.( 일치하는 문자열의 시작 인덱스 :: 17, 일차하는 문자열의 개수 :: 1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;출처: http://www.crocus.co.kr/559 [Crocus]&lt;/p&gt;

&lt;p&gt;주의점:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;머릿속으로 생각하기는 쉬우나 Fail Function 을 만드는 코드가 생각보다는 코딩하기가 헷갈린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void kmp(const string&amp;amp; input, const string&amp;amp; pattern, vector&amp;lt;int&amp;gt;&amp;amp; output) {
    vector&amp;lt;int&amp;gt; fail_table;
    fail_function(pattern, fail_table);   
    int last_pos = 0 ;
    for(auto pos = 0; pos &amp;lt; input.size(); pos++) {
        while(last_pos &amp;gt; 0 &amp;amp;&amp;amp; input[pos] != pattern[last_pos])
            last_pos = fail_table[last_pos-1];
        
        if(input[pos] == pattern[last_pos]){
            if(last_pos == pattern.size() -1) {
                output.push_back(pos);
                last_pos = fail_table[last_pos-1];
            }
            else {
                last_pos++;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>합친 LIS</title>
        <link>/2018/03/03/JIS.html</link>
        <guid isPermaLink="true">/2018/03/03/JIS.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전랙 1권 8.5&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 개의 정수 수열 A와 B에서 각각 길이 0 이상의 증가 부분 수열을 얻은 뒤에 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 함&lt;/li&gt;
  &lt;li&gt;A와 B가 주어질때 합친 LIS의 길이를 계산하는 프로그램을 작성하시오&lt;/li&gt;
  &lt;li&gt;이걸 왜 DP로 풀었는지는 의문이다&lt;/li&gt;
  &lt;li&gt;그냥 합치면 되는거 아닌가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const long long NEGINF = numeric_limit&amp;lt;long long&amp;gt;::min();

int jlis(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, 
         const vector&amp;lt;int&amp;gt;&amp;amp; A, int pos_a, 
         const vector&amp;lt;int&amp;gt;&amp;amp; B, int pos_b) {
    
    // -1부터 시작할 수 있기 때문에 인덱스에 +1을 해준다
    int&amp;amp; ret = cache[pos_a+1][pos_b+1];
    if(ret!= -1) return ret;
    
    ret = 2; // 무조건 두개 이상의 요소가 있기 때문에...
    long long a = (pos_a == -1)?NEGINF:A[pos_a];
    long long b = (pos_b == -1)?NEGINF:B[pos_b];
    long long max_element = max(a,b);
    
    for(int ap = pos_a+1; ap &amp;lt; A.size(); ap++)
        if(max_element &amp;lt; A[ap])
            ret = max(ret, jlis(cache, A, ap, B, pos_b)+1);
    
    for(int bp = pos_b + 1; bp &amp;lt; B.size(); bp++){
        if(max_element &amp;lt; B[bp]){
            ret = max(ret, jlis(cache, A, pos_a, B, bp) +1);
        }
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>이항계수 구하기 - binominal coefficient</title>
        <link>/2018/03/02/%EC%9D%B4%ED%95%AD%EA%B3%84%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%9D%B4%ED%95%AD%EA%B3%84%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;이항계수파스칼의-삼각형-구하기&quot;&gt;이항계수(파스칼의 삼각형) 구하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/pascaltree.png&quot; alt=&quot;파스칼 트리&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파스칼 트리 구하기 문제&lt;/li&gt;
  &lt;li&gt;파스칼 트리와 이항계수의 관계는 이 블로그를 참조: http://blog.naver.com/PostView.nhn?blogId=vollollov&amp;amp;logNo=220947452823&lt;/li&gt;
  &lt;li&gt;간략하게 그림만 보면 아래와 같은 관계가 있다 (출처: 위의 블로그)&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/assets/img/0226_02.gif&quot; alt=&quot;이항계수와파스칼트리&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;(n,r)  = (n-1,r-1) + (n-1,r)&lt;/li&gt;
  &lt;li&gt;이항계수 (n,r)은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수&lt;/li&gt;
  &lt;li&gt;중복계산되는 항이 많기 때문에 메모이제이션 사용해서 계산량 줄이는 것이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드1&quot;&gt;코드1&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int bino(int n, int r) {
    if(r==0 || n==r ) return 1;
    return bino(n-1,r-1) + bino(n-1,r);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;코드2memoization&quot;&gt;코드2(+memoization)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// cache의 초기값은 -1
int bino(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, int n, int r) {
    if(r==0 || n==r) return 1;
    if(cache[n][r]!= -1) return cache[n][r];
    return cache[n][r] = cache[n-1][r-1] + cache[n][r];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>외발뛰기</title>
        <link>/2018/03/02/%EC%99%B8%EB%B0%9C%EB%9B%B0%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%99%B8%EB%B0%9C%EB%9B%B0%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;외발뛰기&quot;&gt;외발뛰기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/jumpgame.png&quot; alt=&quot;외발뛰기&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;게임판의 왼쪽 칸 위에서 오른쪽 칸에 도착하는 하는 것이 가능하는지 파악하는 것이 목적&lt;/li&gt;
  &lt;li&gt;각 게임판에 있는 숫자만큼 아래나 오른쪽으로 이동 가능&lt;/li&gt;
  &lt;li&gt;DP를 사용하며, 메모이제이션을 사용해서 문제를 빨리 해결 가능&lt;/li&gt;
  &lt;li&gt;미로의 끝까지 가는 것을 확인하는 것이 목적이기 때문에, 아래로 바로 내려가거나 오른쪽으로 가는 두 가지 방법중 한가지라도 걸리면, true가 된다&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;점화식: f(x, y) = (f(x, y + map[y][x])&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;f(x+ map[y][x], y))&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool jump(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; map, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, int x, int y) {
    int width = map[0].size();
    int height = map.size();
    if (x &amp;gt;= width || y &amp;gt;= height )
        return false;
    
    if(x==width=1 &amp;amp;&amp;amp; y == height-1)
        return true;

    int&amp;amp; val = cache[y][x];
    if(val != -1)
        return (val==1);
    
    int jumpSize = map[y][x];
    return val = (jump(map, cache, x+jumpSize, y) || jump(map,cache, x, y+jumpSize));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>와일드카드 스트링 매치</title>
        <link>/2018/03/02/%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A7%A4%EC%B9%AD.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A7%A4%EC%B9%AD.html</guid>
        <description>&lt;h2 id=&quot;와일드카드-스트링-매칭&quot;&gt;와일드카드 스트링 매칭&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;흔히쓰는 와일드카드 ?, *을 사용해서 문자열이 해당 패턴에 일치하는지 파악한다&lt;/li&gt;
  &lt;li&gt;예) he?p =&amp;gt; help (O), he?p =&amp;gt; helpp (X), h&lt;em&gt;p =&amp;gt; help (O), h&lt;/em&gt;p =&amp;gt; helpp (O)&lt;/li&gt;
  &lt;li&gt;DP를 사용해서 문제를 풀 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문자열와 패턴을 각각 W, S라고 하자.&lt;/li&gt;
  &lt;li&gt;만약 현재 위치 w,s에 대해 W[w] != S[s]이면 해당 없음&lt;/li&gt;
  &lt;li&gt;W[w] == S[s] 이거나 W[w] == ‘?’이면 매칭이고, 다음 글자 를 계속 조사&lt;/li&gt;
  &lt;li&gt;매칭하지 않아도 W[w] == ‘*‘이면 이후의 글자들을 전부 조사해서 매칭이 되는지의 여부를 파악한다&lt;/li&gt;
  &lt;li&gt;W의 w+1과 S의 s+1 이후의 값들을 확인해서 하나라도 참이면 답은 참이 된다&lt;/li&gt;
  &lt;li&gt;시간복잡도는 O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;점화식&quot;&gt;점화식&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    bool matchWords(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, 
        const string&amp;amp; W,
        int w, 
        const string&amp;amp; S,
        int s) {

            int&amp;amp; ret = cache[w][s];
            if(ret != -1)
                return ret;
            
            while(s &amp;lt; S.size() &amp;amp;&amp;amp; w &amp;lt; W.size() &amp;amp;&amp;amp;
                    (W[w] == '?' || W[w] == S[s]) {
                        ++w;
                        ++s;
                    }
            
            if(w==W.size()) return ret = (s==S.size());
            if(W[w] == '*') {
                if(matchWords(cache, W, w+1, S, s) ||
                    (s &amp;lt; S.size() &amp;amp;&amp;amp; matchWords(cache, W, w, S, s+1))
                    return ret = 1;
            }

            return ret = 0;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>삼각형에서의 최대 경로</title>
        <link>/2018/03/02/%EC%82%BC%EA%B0%81%ED%98%95%EC%97%90%EC%84%9C%EC%9D%98%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%82%BC%EA%B0%81%ED%98%95%EC%97%90%EC%84%9C%EC%9D%98%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C.html</guid>
        <description>&lt;h2 id=&quot;삼각형에서의-최대-경로&quot;&gt;삼각형에서의 최대 경로&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6
1 2
3 7 4
9 4 1 7
2 7 5 9 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;맨 위의 숫자에서 시작해서 한 번에 한 칸씩 아래(바로 아래(y+1), 오른쪽 아래(x+1, y+1)로 내려가서 맨 아래줄에 도달하는 경로중 숫자의 합을 최대화 하는 경로는?&lt;/li&gt;
  &lt;li&gt;경로가 여러개가 있기 때문에 메모이제이션이 쉽지 않음&lt;/li&gt;
  &lt;li&gt;f(x,y,sum) = max(f(x+1,y, sum + triangle[y][x]), f(x,y+1, sum + triangle[y][x]))
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int maxSum(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; input,
              vector&amp;lt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;gt;&amp;amp; cache,
              int x,
              int y, int sum) {
                  if(y == n-1)
                      return sum + input[y][x];
                    
                  int&amp;amp; val = cache[y][x][sum];
                  if(val != -1)
                      return val;
                    
                  sum += input[y][x];
                  return max(
                      maxSum(input, cache, x+1, y+1, sum),
                      maxSum(input, cache, x, y+1, sum)
                  );
              }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;재귀함수에 sum을 더해줄 필요가 없다. sum이 있건 없건 부분 경로의 최대 값이 중요하다&lt;/li&gt;
  &lt;li&gt;Optimal Substructure&lt;/li&gt;
  &lt;li&gt;f(x,y) = max(f(x+1,y), f(x,y+1)) + triangle[y][x];
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int maxSum(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; input,
              vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache,
              int x,
              int y) {

                  int&amp;amp; ret = cache[y][x];

                  if(ret != -1)
                      return ret;

                  if(y==n-1)
                      return input[y][x];
                    
                  return ret = max(
                                  maxSum(input, cache, x+1, y+1),
                                  maxSum(input, cache, x, y+1)

                  );
              }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;시간복잡도 - 부분 문제에서는 O(N&lt;sup&gt;2&lt;/sup&gt;), 전체문제에서는 상수 시간이 추가되기 때문에 결국 O(N&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
  </channel>
</rss>
