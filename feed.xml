<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c0dingcat</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>daily log</description>
    <pubDate>Sun, 04 Mar 2018 02:09:45 -0800</pubDate>
    
      <item>
        <title>타일링 방법의 수 세기</title>
        <link>/2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html</link>
        <guid isPermaLink="true">/2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제설명&quot;&gt;문제설명&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/tiling1.png&quot; alt=&quot;타일링&quot; /&gt;
&lt;img src=&quot;/assets/img/tiling2.png&quot; alt=&quot;타일링&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2&lt;em&gt;n 크기의 사각형을 2&lt;/em&gt;1 크기의 타일로 채우는 방법의 수를 계산하는 문제&lt;/li&gt;
  &lt;li&gt;타일을 길게 붙이거나 (2&lt;em&gt;1) 혹은 옆으로 누워서 붙이는 경우 (2&lt;/em&gt;n)로 붙이는 경우를 생각해서 계산&lt;/li&gt;
  &lt;li&gt;즉, f(n) = f(n-1) + f(n-2)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const int mod_num = 1000000007;

int tiling(const vector&amp;lt;int&amp;gt;&amp;amp; input, int width) {
    if(width &amp;lt;=1) return 1;
    int &amp;amp; ret = cache[width];
    if(ret !=-1) return ret;
    return ret = (tiling(input, width-2) + tiling(input, width-1))%mod_num;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>원주율 외우기</title>
        <link>/2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 문제 8.7&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;원주율을 몇 만 자리까지 외우기 위해 일반적으로 쓰는 방법은 3~5글자 정도로 끓어서 외운다&lt;/li&gt;
  &lt;li&gt;주어진 숫자에 대해 최소의 난이도를 구하는 방법을 계산하시오
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;경우                  예                   난이도
모든 숫자가 같을때               ex)333,55555         1
숫자가 1씩 증가 혹은 감소         ex)23456,3210        2
두개의 숫자가 번갈아 가면서 나타날때  ex)323, 54545       4
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DP를 써서 점화식을 먼저 세운다&lt;/li&gt;
  &lt;li&gt;F(L) = min(F(L,3), F(L,4), F(L,5))&lt;/li&gt;
  &lt;li&gt;F(L,3) -&amp;gt; min(F(L,4), F(L,5), F(L,6)) + classify(L,3)&lt;/li&gt;
  &lt;li&gt;classify하는 부분은 경우에 따라 파싱하면 됨&lt;/li&gt;
  &lt;li&gt;DP의 점화식에 따른 구현을 눈여겨 보도록 하자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int classify(const string&amp;amp; input, int spos, int length) {
    /// 문자열을 끓어서 classify 해서 돌려준다
}

int memorize(const string&amp;amp; input, vector&amp;lt;int&amp;gt;&amp;amp; cache, int begin) {
    if(begin == input.size())
        return 0;
    
    int&amp;amp; ret = cache[begin];
    if(ret != -1)
        return ret;
    ret = INF;
    // 3~5글자 사이로 끓어 읽어서 최소값을 구한다
    for(int L = 3 ; L &amp;lt;= 5; ++L) {
        if(begin + L &amp;lt;= input.size()) {
            ret = min(ret,
                     memorize(input, cache, begin+L) + classify(input, begin, L));
        }
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>삼각형 위의 최대 경로 개수 세기</title>
        <link>/2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제설명&quot;&gt;문제설명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이전의 문제는 최대 경로의 합을 구했을뿐, 경로 자체는 구하지 않았다&lt;/li&gt;
  &lt;li&gt;최대 경로는 유일하지 않을 수도 있다&lt;/li&gt;
  &lt;li&gt;문제를 해결하기 위해 두 개의 다른 동적 계획법 문제를 해결&lt;/li&gt;
  &lt;li&gt;합을 먼저 구하고, 그 합을 구하는 도중에 만든 캐싱을 통해 패스를 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct triangle {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; input;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; cache;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; countCache;
    
    int path(int y, int x) {
        if(y == input.size() -1)
            return input[y][x];
        
        int&amp;amp; ret = cache[y][x];
        if(ret != -1)
            return ret;
        
        return ret = max(path(y+1,x), path(y+1,x+1))+input[y][x];
    }
    
    int count(int y, int x) {
        if(y==input.size()-1)
            return 1;
        
        int &amp;amp; ret = countCache[y][x];
        if(ret!=-1)
            return ret;
        
        if(path(y+1,x+1)&amp;gt;=path(y+1,x))
            ret += path(y+1,x+1);
        if(path(y+1,x+1)&amp;lt;=path(y+1,x))
            ret += path(y+1,x);
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>Get Max Even Sum From Tree</title>
        <link>/2018/03/03/get-max-even-sum-from-tree.html</link>
        <guid isPermaLink="true">/2018/03/03/get-max-even-sum-from-tree.html</guid>
        <description>
&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;output the maximum EVEN sum along any path&lt;/li&gt;
  &lt;li&gt;![/assets/img/maxevensum.png]&lt;/li&gt;
  &lt;li&gt;트리의 각 노드들을 더해서 최대값이자 짝수인 값을 구하기&lt;/li&gt;
  &lt;li&gt;짝수가 된다는 말에 잘 주목을 해야 할 것 같다&lt;/li&gt;
  &lt;li&gt;답이 없어서 정확하게 파악은 안되지만…&lt;/li&gt;
  &lt;li&gt;모든 경로마다의 합을 구해서 정렬을 해서 짝수를 구하는 방법이 있지만, 이건 별로 안좋아할듯&lt;/li&gt;
  &lt;li&gt;그게 아니면 짝수가 되는 경우를 확인해서 최대 값을 구하는 방법이 있을것 같다&lt;/li&gt;
  &lt;li&gt;문제가 워낙 간단하게 나와서 정확한 제약조건은 알 길이 없지만, 만약 정할 수 있다면 루트를 거쳐야 한다와 마이너스 값은 허용되지 않음 두가지 경우를 설정하고 싶다&lt;/li&gt;
  &lt;li&gt;루트를 거쳐야 한다면 루트가 홀수인 경우는 왼쪽이 홀수 아니면 오른쪽이 홀수 값을 리턴해야 한다&lt;/li&gt;
  &lt;li&gt;루트가 짝수인 경우는 왼쪽, 오른쪽 둘다 홀수 혹은 짝수가 되어야 한다&lt;/li&gt;
  &lt;li&gt;그리고 post order 방식으로 트리를 순환하고, 노도의 값을 먼저 더해서 노드의 왼쪽 오른쪽 노드의 탐색이 끝난 후에 값을 확인한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

struct node {
    int value;
    node* left, *right;
    node(int n):value(n){}
};

int oddNodeAdd(node* ptr, int total) {
    if(!ptr)
        return total;
    
    int left = oddNodeAdd(ptr-&amp;gt;left, total + ptr-&amp;gt;value);
    int right = oddNodeAdd(ptr-&amp;gt;right, total + ptr-&amp;gt;value);
    
    int ld = left % 2, rd = right % 2;
    if(ld == 1 &amp;amp;&amp;amp; rd ==1)
        return max(left, right);
    
    if(ld==1 &amp;amp;&amp;amp; rd==0)
        return ld;
    
    if(rd==1 &amp;amp;&amp;amp; ld==0) 
        return rd;
    
    return total;
}

int evenNodeAdd(node* ptr, int total) {
    
    if(!ptr)
        return 0 ;
    
    int left = evenNodeAdd(ptr-&amp;gt;left, total + ptr-&amp;gt;value);
    int right = evenNodeAdd(ptr-&amp;gt;right, total + ptr-&amp;gt;value);
    
    // 
    int ld = left %2, rd = right%2;
    
    if((ld ==0&amp;amp;&amp;amp;rd ==0)) {
        return max(left, right);
    }
    
    if(ld==1&amp;amp;&amp;amp;ld==0) {
        return rd;
    }
    
    if(ld==0&amp;amp;&amp;amp;rd==1) {
        return ld;
    }

    return total;
}

int getMaxEvenNumber(node* ptr) {
    
    int maxValue = 0 ;
    int oddLeft = oddNodeAdd(ptr-&amp;gt;left,0);
    int oddRight = oddNodeAdd(ptr-&amp;gt;right, 0);
    int evenLeft = evenNodeAdd(ptr-&amp;gt;right,0);
    int evenRight = evenNodeAdd(ptr-&amp;gt;right,0);
    
    maxValue = max(oddLeft + oddRight, evenLeft + evenRight);
    maxValue = max(maxValue, max(oddLeft+evenRight, evenLeft+oddRight));
    maxValue = maxValue + ptr-&amp;gt;value; 
    
    return maxValue;
}

int main() {
    node* ptr = new node(10);
    ptr-&amp;gt;left = new node(2);
    ptr-&amp;gt;left-&amp;gt;left = new node(1);
    ptr-&amp;gt;left-&amp;gt;right = new node(101);
    ptr-&amp;gt;right = new node(5);
    ptr-&amp;gt;right-&amp;gt;right = new node(13);  
    cout &amp;lt;&amp;lt; getMaxEvenNumber(ptr);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>KMP 알고리즘</title>
        <link>/2018/03/03/Shortest-Palindrome.html</link>
        <guid isPermaLink="true">/2018/03/03/Shortest-Palindrome.html</guid>
        <description>&lt;h2 id=&quot;shortest-palindrome&quot;&gt;Shortest Palindrome&lt;/h2&gt;

&lt;h3 id=&quot;출처&quot;&gt;출처&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://leetcode.com/problems/shortest-palindrome/description/&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문제&quot;&gt;문제&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주어진 스티링 S에 대해서 글자들을 앞부분에 더해서 회문으로 만들 수 있다. 이때, 가장 짧은 글자를 더해서 만들 수 있는 회문을 구하라.&lt;/li&gt;
  &lt;li&gt;Given “aacecaaa”, return “aaacecaaa”.
Given “abcd”, return “dcbabcd”.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분석&quot;&gt;분석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bruteforce로 할 수 있는 방법:
    &lt;ul&gt;
      &lt;li&gt;S를 reverse 해서 reversed 된 스트링의 substring과 S의 서브스트링을 비교한다.&lt;/li&gt;
      &lt;li&gt;Time complexity: O(N2)&lt;/li&gt;
      &lt;li&gt;Space complexity: O(N)
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string shortestPalindrome(string s)
{
 int n = s.size();
 string rev(s);
 reverse(rev.begin(), rev.end());
 int j = 0;
 for (int i = 0; i &amp;lt; n; i++) {
  if (s.substr(0, n - i) == rev.substr(i))
      return rev.substr(0, i) + s;
 }
 return &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KMP 방식을 사용한다
    &lt;ul&gt;
      &lt;li&gt;KMP 방식에 따라 Fail function lookup table 을 만들면 얼마만큼의 prefix가 현재까지 매칭되었는지를 알 수 있고 이 값을 사용해서 panlindrome을 만들기 위해 필요한 문자열을 알 수 있게 된다.&lt;/li&gt;
      &lt;li&gt;입력 S을 reverse한후 ‘#’ 와 함께 원래 입력에 더한다 string input = s + ‘#’ + reverse(s)&lt;/li&gt;
      &lt;li&gt;’#’은 원래 값과 reverse된 문자열이 섞이지 않도록 필요&lt;/li&gt;
      &lt;li&gt;KMP fail_function을 만들어서 surfix와 동일한 prefix의 최장 길이를 구할 수 있고 이 길이를 알면 reverse된 문자열에서 필요한 문자열을 뽑아낼 수 있다
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  string shortestPalindrome(string input) {
        
  int n = input.length();
  string rev(input);
  std::reverse(rev.begin(), rev.end());
        
  string source = input + &quot;#&quot; + rev;
  int len = source.size();   
         
  vector&amp;lt;int&amp;gt; fail_table(len, 0);
        
  for(int pos = 1; pos &amp;lt; len; pos++){
      int last_match_pos = fail_table[pos-1];
      while(last_match_pos &amp;gt; 0 
            &amp;amp;&amp;amp; source[pos] != source[last_match_pos])
          last_match_pos = fail_table[last_match_pos-1];
            
      if(source[pos] == source[last_match_pos])
          ++last_match_pos;
            
      fail_table[pos] = last_match_pos;
  } 
        
  return rev.substr(0, n - fail_table[len - 1]) + input;         
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>KMP 알고리즘</title>
        <link>/2018/03/03/KMP-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/2018/03/03/KMP-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://www.crocus.co.kr/559&lt;/li&gt;
  &lt;li&gt;http://jason9319.tistory.com/130&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kmp-알고리즘kmp-algorithm&quot;&gt;KMP 알고리즘(KMP Algorithm)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;www.crocus.co.kr&lt;/li&gt;
  &lt;li&gt;KMP 방식을 요약하면..
    &lt;ul&gt;
      &lt;li&gt;패턴의 substring을 만들어서 prefix 와 suffix가 같을때의 최장 길이를 찾는다
ex) aba =&amp;gt; 1, aabaa =&amp;gt;2, acdefa =&amp;gt; 1 ..&lt;/li&gt;
      &lt;li&gt;패턴의 substring 매칭에 대한 테이블을 만든다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/assets/img/kmp.png&quot; alt=&quot;KMP fail table&quot; /&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void fail_function(const string&amp;amp; input, vector&amp;lt;int&amp;gt;&amp;amp; output) {
  output.resize(input.size(),0);  
  int last_pos = 0;
  for(auto pos = 1; pos &amp;lt; input.size(); pos++) {
  while(last_pos &amp;gt;0 &amp;amp;&amp;amp; input[pos] != input[last_pos])
      last_pos = output[last_pos-1];
        
  if(input[pos] == input[last_pos])
      output[pos] = ++last_pos;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;source = aabaabaaaabaabaadaabaabac가 있다고 가정하자.&lt;/li&gt;
  &lt;li&gt;pattern = aabaabac를 찾으려 한다면 표를 다음과 같이 이용하면 된다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaaba[a]aabaabaadaabaabac
aabaaba[c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaaba까지 같다. 따라서 arr[i]의 7번째 인덱스에서 a와 c가 틀렸으니,aabaaba의 f[6] = 4 따라서 (7-4) = 3인 arr[3]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaa[a]abaabaadaabaabac
 aabaa[b]ac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaa까지 같다. 따라서 arr[i]의 8번째 인덱스에서 a와 b가 틀렸으니, aabaa의 f[i] = 2 따라서 (8-2) = 6인 arr[6]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaa[a]abaabaadaabaabac
　　　 aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aa까지 같다. 따라서 arr[i]의 8번째 인덱스에서 a와 b가 틀렸으니, aa의 f[i] = 1 따라서 (8-1) = 7인 arr[7]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaa[a]abaabaadaabaabac
　　　 aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aa까지 같다. 따라서 arr[i]의 9번째 인덱스에서 a와 b가 틀렸으니, aa의 f[i] = 1 따라서 (9-1) = 8인 arr[8]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaa[a]baabaadaabaabac
　　　  aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaaba까지 같다. 따라서 arr[i]의 15번째 인덱스에서 a와 c가 틀렸으니, aabaaba의 f[i] = 4 따라서 (15-4) = 11인 arr[11]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaaba[a]daabaabac
　　　　　aabaaba[c]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aabaa까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 b가 틀렸으니, aabaa의 f[i] = 2 따라서 (16-2) = 14인 arr[14]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaa[d]aabaabac
　　　　　　 aabaa[b]ac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: aa까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 b가 틀렸으니, aa의 f[i] = 1 따라서 (16-1) = 15인 arr[15]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaa[d]aabaabac
　　　　　　    aa[b]aabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: a까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 a가 틀렸으니, a의 f[i] = 0  따라서 (16-0) = 16인 arr[16]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaa[d]aabaabac
　　　　　　　   a[a]baabac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: 같은 것이 없다. 따라서 arr[17]부터 다시 확인한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aabaabaaaabaabaad[aabaabac]
　　　　　　　      [aabaabac]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비교결과 :: 모두 일치. 정답을 도출한다.( 일치하는 문자열의 시작 인덱스 :: 17, 일차하는 문자열의 개수 :: 1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;출처: http://www.crocus.co.kr/559 [Crocus]&lt;/p&gt;

&lt;p&gt;주의점:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;머릿속으로 생각하기는 쉬우나 Fail Function 을 만드는 코드가 생각보다는 코딩하기가 헷갈린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void kmp(const string&amp;amp; input, const string&amp;amp; pattern, vector&amp;lt;int&amp;gt;&amp;amp; output) {
    vector&amp;lt;int&amp;gt; fail_table;
    fail_function(pattern, fail_table);   
    int last_pos = 0 ;
    for(auto pos = 0; pos &amp;lt; input.size(); pos++) {
        while(last_pos &amp;gt; 0 &amp;amp;&amp;amp; input[pos] != pattern[last_pos])
            last_pos = fail_table[last_pos-1];
        
        if(input[pos] == pattern[last_pos]){
            if(last_pos == pattern.size() -1) {
                output.push_back(pos);
                last_pos = fail_table[last_pos-1];
            }
            else {
                last_pos++;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>합친 LIS</title>
        <link>/2018/03/03/JIS.html</link>
        <guid isPermaLink="true">/2018/03/03/JIS.html</guid>
        <description>&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 문제 해결 전랙 1권 8.5&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 개의 정수 수열 A와 B에서 각각 길이 0 이상의 증가 부분 수열을 얻은 뒤에 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 함&lt;/li&gt;
  &lt;li&gt;A와 B가 주어질때 합친 LIS의 길이를 계산하는 프로그램을 작성하시오&lt;/li&gt;
  &lt;li&gt;이걸 왜 DP로 풀었는지는 의문이다&lt;/li&gt;
  &lt;li&gt;그냥 합치면 되는거 아닌가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const long long NEGINF = numeric_limit&amp;lt;long long&amp;gt;::min();

int jlis(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, 
         const vector&amp;lt;int&amp;gt;&amp;amp; A, int pos_a, 
         const vector&amp;lt;int&amp;gt;&amp;amp; B, int pos_b) {
    
    // -1부터 시작할 수 있기 때문에 인덱스에 +1을 해준다
    int&amp;amp; ret = cache[pos_a+1][pos_b+1];
    if(ret!= -1) return ret;
    
    ret = 2; // 무조건 두개 이상의 요소가 있기 때문에...
    long long a = (pos_a == -1)?NEGINF:A[pos_a];
    long long b = (pos_b == -1)?NEGINF:B[pos_b];
    long long max_element = max(a,b);
    
    for(int ap = pos_a+1; ap &amp;lt; A.size(); ap++)
        if(max_element &amp;lt; A[ap])
            ret = max(ret, jlis(cache, A, ap, B, pos_b)+1);
    
    for(int bp = pos_b + 1; bp &amp;lt; B.size(); bp++){
        if(max_element &amp;lt; B[bp]){
            ret = max(ret, jlis(cache, A, pos_a, B, bp) +1);
        }
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>이항계수 구하기 - binominal coefficient</title>
        <link>/2018/03/02/%EC%9D%B4%ED%95%AD%EA%B3%84%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%9D%B4%ED%95%AD%EA%B3%84%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;이항계수파스칼의-삼각형-구하기&quot;&gt;이항계수(파스칼의 삼각형) 구하기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/pascaltree.png&quot; alt=&quot;파스칼 트리&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파스칼 트리 구하기 문제&lt;/li&gt;
  &lt;li&gt;파스칼 트리와 이항계수의 관계는 이 블로그를 참조: http://blog.naver.com/PostView.nhn?blogId=vollollov&amp;amp;logNo=220947452823&lt;/li&gt;
  &lt;li&gt;간략하게 그림만 보면 아래와 같은 관계가 있다 (출처: 위의 블로그)&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/assets/img/0226_02.gif&quot; alt=&quot;이항계수와파스칼트리&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;(n,r)  = (n-1,r-1) + (n-1,r)&lt;/li&gt;
  &lt;li&gt;이항계수 (n,r)은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수&lt;/li&gt;
  &lt;li&gt;중복계산되는 항이 많기 때문에 메모이제이션 사용해서 계산량 줄이는 것이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드1&quot;&gt;코드1&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int bino(int n, int r) {
    if(r==0 || n==r ) return 1;
    return bino(n-1,r-1) + bino(n-1,r);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;코드2memoization&quot;&gt;코드2(+memoization)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// cache의 초기값은 -1
int bino(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, int n, int r) {
    if(r==0 || n==r) return 1;
    if(cache[n][r]!= -1) return cache[n][r];
    return cache[n][r] = cache[n-1][r-1] + cache[n][r];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>외발뛰기</title>
        <link>/2018/03/02/%EC%99%B8%EB%B0%9C%EB%9B%B0%EA%B8%B0.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%99%B8%EB%B0%9C%EB%9B%B0%EA%B8%B0.html</guid>
        <description>&lt;h2 id=&quot;외발뛰기&quot;&gt;외발뛰기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/jumpgame.png&quot; alt=&quot;외발뛰기&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;게임판의 왼쪽 칸 위에서 오른쪽 칸에 도착하는 하는 것이 가능하는지 파악하는 것이 목적&lt;/li&gt;
  &lt;li&gt;각 게임판에 있는 숫자만큼 아래나 오른쪽으로 이동 가능&lt;/li&gt;
  &lt;li&gt;DP를 사용하며, 메모이제이션을 사용해서 문제를 빨리 해결 가능&lt;/li&gt;
  &lt;li&gt;미로의 끝까지 가는 것을 확인하는 것이 목적이기 때문에, 아래로 바로 내려가거나 오른쪽으로 가는 두 가지 방법중 한가지라도 걸리면, true가 된다&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;점화식: f(x, y) = (f(x, y + map[y][x])&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;f(x+ map[y][x], y))&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool jump(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; map, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, int x, int y) {
    int width = map[0].size();
    int height = map.size();
    if (x &amp;gt;= width || y &amp;gt;= height )
        return false;
    
    if(x==width=1 &amp;amp;&amp;amp; y == height-1)
        return true;

    int&amp;amp; val = cache[y][x];
    if(val != -1)
        return (val==1);
    
    int jumpSize = map[y][x];
    return val = (jump(map, cache, x+jumpSize, y) || jump(map,cache, x, y+jumpSize));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>와일드카드 스트링 매치</title>
        <link>/2018/03/02/%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A7%A4%EC%B9%AD.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A7%A4%EC%B9%AD.html</guid>
        <description>&lt;h2 id=&quot;와일드카드-스트링-매칭&quot;&gt;와일드카드 스트링 매칭&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;흔히쓰는 와일드카드 ?, *을 사용해서 문자열이 해당 패턴에 일치하는지 파악한다&lt;/li&gt;
  &lt;li&gt;예) he?p =&amp;gt; help (O), he?p =&amp;gt; helpp (X), h&lt;em&gt;p =&amp;gt; help (O), h&lt;/em&gt;p =&amp;gt; helpp (O)&lt;/li&gt;
  &lt;li&gt;DP를 사용해서 문제를 풀 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관찰&quot;&gt;관찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문자열와 패턴을 각각 W, S라고 하자.&lt;/li&gt;
  &lt;li&gt;만약 현재 위치 w,s에 대해 W[w] != S[s]이면 해당 없음&lt;/li&gt;
  &lt;li&gt;W[w] == S[s] 이거나 W[w] == ‘?’이면 매칭이고, 다음 글자 를 계속 조사&lt;/li&gt;
  &lt;li&gt;매칭하지 않아도 W[w] == ‘*‘이면 이후의 글자들을 전부 조사해서 매칭이 되는지의 여부를 파악한다&lt;/li&gt;
  &lt;li&gt;W의 w+1과 S의 s+1 이후의 값들을 확인해서 하나라도 참이면 답은 참이 된다&lt;/li&gt;
  &lt;li&gt;시간복잡도는 O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;점화식&quot;&gt;점화식&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    bool matchWords(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache, 
        const string&amp;amp; W,
        int w, 
        const string&amp;amp; S,
        int s) {

            int&amp;amp; ret = cache[w][s];
            if(ret != -1)
                return ret;
            
            while(s &amp;lt; S.size() &amp;amp;&amp;amp; w &amp;lt; W.size() &amp;amp;&amp;amp;
                    (W[w] == '?' || W[w] == S[s]) {
                        ++w;
                        ++s;
                    }
            
            if(w==W.size()) return ret = (s==S.size());
            if(W[w] == '*') {
                if(matchWords(cache, W, w+1, S, s) ||
                    (s &amp;lt; S.size() &amp;amp;&amp;amp; matchWords(cache, W, w, S, s+1))
                    return ret = 1;
            }

            return ret = 0;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>삼각형에서의 최대 경로</title>
        <link>/2018/03/02/%EC%82%BC%EA%B0%81%ED%98%95%EC%97%90%EC%84%9C%EC%9D%98%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C.html</link>
        <guid isPermaLink="true">/2018/03/02/%EC%82%BC%EA%B0%81%ED%98%95%EC%97%90%EC%84%9C%EC%9D%98%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C.html</guid>
        <description>&lt;h2 id=&quot;삼각형에서의-최대-경로&quot;&gt;삼각형에서의 최대 경로&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6
1 2
3 7 4
9 4 1 7
2 7 5 9 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;맨 위의 숫자에서 시작해서 한 번에 한 칸씩 아래(바로 아래(y+1), 오른쪽 아래(x+1, y+1)로 내려가서 맨 아래줄에 도달하는 경로중 숫자의 합을 최대화 하는 경로는?&lt;/li&gt;
  &lt;li&gt;경로가 여러개가 있기 때문에 메모이제이션이 쉽지 않음&lt;/li&gt;
  &lt;li&gt;f(x,y,sum) = max(f(x+1,y, sum + triangle[y][x]), f(x,y+1, sum + triangle[y][x]))
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int maxSum(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; input,
              vector&amp;lt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;gt;&amp;amp; cache,
              int x,
              int y, int sum) {
                  if(y == n-1)
                      return sum + input[y][x];
                    
                  int&amp;amp; val = cache[y][x][sum];
                  if(val != -1)
                      return val;
                    
                  sum += input[y][x];
                  return max(
                      maxSum(input, cache, x+1, y+1, sum),
                      maxSum(input, cache, x, y+1, sum)
                  );
              }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;재귀함수에 sum을 더해줄 필요가 없다. sum이 있건 없건 부분 경로의 최대 값이 중요하다&lt;/li&gt;
  &lt;li&gt;Optimal Substructure&lt;/li&gt;
  &lt;li&gt;f(x,y) = max(f(x+1,y), f(x,y+1)) + triangle[y][x];
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int maxSum(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; input,
              vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; cache,
              int x,
              int y) {

                  int&amp;amp; ret = cache[y][x];

                  if(ret != -1)
                      return ret;

                  if(y==n-1)
                      return input[y][x];
                    
                  return ret = max(
                                  maxSum(input, cache, x+1, y+1),
                                  maxSum(input, cache, x, y+1)

                  );
              }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;시간복잡도 - 부분 문제에서는 O(N&lt;sup&gt;2&lt;/sup&gt;), 전체문제에서는 상수 시간이 추가되기 때문에 결국 O(N&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>최장 공통 부분 문자열 - Longest Common Substring</title>
        <link>/2018/03/01/longest-common-substring.html</link>
        <guid isPermaLink="true">/2018/03/01/longest-common-substring.html</guid>
        <description>&lt;h2 id=&quot;설명&quot;&gt;설명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Longest Common Subsequence 문제와 거의 유사하지만 약간 다른 문제&lt;/li&gt;
  &lt;li&gt;아까의 로직과 비슷하다, 다만 문자열의 경우는 subsequence가 아니기 때문에 중간에 어긋나면 리셋이 가능하다&lt;/li&gt;
  &lt;li&gt;DP로 풀 수 있는 가장 일반적인 솔루션&lt;/li&gt;
  &lt;li&gt;두 개의 문자열에 대한 테이블을 만든다&lt;/li&gt;
  &lt;li&gt;LCSubstr(X, Y, m, n) = LCSubstr(X, Y, m-1, n-1) + 1 if X[m-1] = Y[n-1] 0  Otherwise (if X[m-1] != Y[n-1])&lt;/li&gt;
  &lt;li&gt;LCSubStr(X, Y, m, n)  = Max(LCSubstr(X, Y, i, j)) where 1 &amp;lt;= i &amp;lt;= m and 1 &amp;lt;= j &amp;lt;= n&lt;/li&gt;
  &lt;li&gt;시간 복잡도는 문자열 A가 N개의 글자로 이루어진 문자열이고 문자열 B가 M개의 글자로 이루어진 문자열이라면, N&lt;em&gt;M 번의 검사를 통해 테이블을 만들어야 하기 때문에 결국 O(N&lt;/em&gt;M)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    for(int i = 0 ; i &amp;lt; A.size(); i++) {
        for(int j = 0; j &amp;lt; B.size(); j++) {
            if(A[i] == B[j]) {
                table[i][j] = table[i-1][j-1] + 1;
                result = max(result, table[i][j]);
            }
            else {
                table[i][j] = 0 ;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>최장 공통 부분 수열 - Longest Common Subsequence</title>
        <link>/2018/03/01/longest-common-sequence.html</link>
        <guid isPermaLink="true">/2018/03/01/longest-common-sequence.html</guid>
        <description>&lt;h2 id=&quot;설명&quot;&gt;설명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 문자열이 주어졌을 때, 두 문자열에 모두 포함된 가장 긴 공통 부분 문자열을 찾는 프로그램을 작성하시오.&lt;/li&gt;
  &lt;li&gt;두 문자열 ABRACADABRA와 ECADADABRBCRDARA의 공통 부분 문자열은 CA, CADA, ADABR, 빈 문자열 등이 있다. 이 중에서 가장 긴 공통 부분 문자열은 ADABR이며, 길이는 5이다. 또, 두 문자열이 UPWJCIRUCAXIIRGL와 SBQNYBSBZDFNEV인 경우에는 가장 긴 공통 부분 문자열은 빈 문자열이다.&lt;/li&gt;
  &lt;li&gt;두 개의 문자열에 대한 테이블을 만든다&lt;/li&gt;
  &lt;li&gt;LCS(X&lt;sub&gt;i&lt;/sub&gt;, Y&lt;sub&gt;j&lt;/sub&gt;) = 0 if x&lt;sub&gt;i&lt;/sub&gt; = 0 or y&lt;sub&gt;j&lt;/sub&gt; = 0&lt;/li&gt;
  &lt;li&gt;LCS(X&lt;sub&gt;i&lt;/sub&gt;, Y&lt;sub&gt;j&lt;/sub&gt;) = LCS(X&lt;sub&gt;i-1&lt;/sub&gt;, Y&lt;sub&gt;j-1&lt;/sub&gt;) +  1 if x&lt;sub&gt;i&lt;/sub&gt; = y&lt;sub&gt;j&lt;/sub&gt;&lt;/li&gt;
  &lt;li&gt;LCS(X&lt;sub&gt;i&lt;/sub&gt;, Y&lt;sub&gt;j&lt;/sub&gt;) = longest(LCS(X&lt;sub&gt;i-1&lt;/sub&gt;, Y&lt;sub&gt;j&lt;/sub&gt;),LCS(X&lt;sub&gt;i&lt;/sub&gt;, Y&lt;sub&gt;j-1&lt;/sub&gt;))  if x&lt;sub&gt;i&lt;/sub&gt; != y&lt;sub&gt;j&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int LCS(const string&amp;amp; input, const string&amp;amp; compare) {
    
    if(input.size() == 0 || compare.size() == 0)
        return 0 ;
    
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; table;
    for(int i = 0 ; i &amp;lt; input.size(); i++){
        vector&amp;lt;int&amp;gt; v(compare.size(), 0);
        table.push_back(v);
    }
    
    if(input[0] == compare[0])
        table[0][0] = 1;
    
    for(int x = 1; x &amp;lt; input.size(); x++) {
        for(int y = 1; y &amp;lt; compare.size(); y++){
            if(input[x] == compare[y]) {
                table[x][y] = table[x-1][y-1] + 1;
            }
            else {
                table[x][y] = max(table[x][y-1], table[x-1][y]);
            }
        }
    }
    int ret = table[input.size()-1][compare.size()-1]; 
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;아래의 설명은 http://hsp1116.tistory.com/37 에서 가져옴&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;i&lt;/sub&gt; == B&lt;sub&gt;j&lt;/sub&gt;일 때 LCS(i,j) = LCS(i-1,j-1) + 1 이기 떄문에 LCS(i,j) &amp;gt; LCS(i-1,j-1)&lt;/li&gt;
  &lt;li&gt;LCX(i,j) = max(LCS(i-1,j),LCS(i,j-1))의 경우:&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;i&lt;/sub&gt; != B&lt;sub&gt;j&lt;/sub&gt;일 지라도, LCS(i,j) = max(LCS(i-1,j),LCS(i,j-1))를 통해 LCS(i-1,j-1) + 1가 도출 될 수 있다.&lt;/li&gt;
  &lt;li&gt;LCS(i-1,j), LCS(i,j-1)이 둘 다 LCS(i,j)보다 작고 LCS(i-1,j-1)이 LCS(i,j)보다 작은 경우가 Ai==Bj일 때이다.&lt;/li&gt;
  &lt;li&gt;LCS[i][j] &amp;gt; LCS[i-1][j-1] &amp;amp;&amp;amp; LCS[i][j] &amp;gt; LCS[i][j-1] &amp;amp;&amp;amp; LCS[i][j] &amp;gt; LCS[i-1][j])를 조건으로 코드를 구현하면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTracking(int m, int n){
    if(m==0 || n ==0) return;
    if(cache[m][n] &amp;amp;gt; cache[m-1][n-1] &amp;amp;amp;&amp;amp;amp; cache[m][n] &amp;amp;gt; cache[m][n-1] &amp;amp;amp;&amp;amp;amp; cache[m][n] &amp;amp;gt; cache[m-1][n]){
        &amp;lt;span style=&quot;color: rgb(174, 174, 174);&quot; data-evernote-id=&quot;407&quot; class=&quot;js-evernote-checked&quot;&amp;gt;//문자열 인덱스는 캐시 인덱스보다 1씩 더 작다. &amp;lt;/span&amp;gt;
        output = input[n-1] + output;
        backTracking(m-1, n-1);
    }else if(cache[m][n] &amp;amp;gt; cache[m-1][n] &amp;amp;amp;&amp;amp;amp; cache[m][n] == cache[m][n-1]){
        backTracking(m, n-1);
    }else{
          backTracking(m-1, n);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-및-추가-설명&quot;&gt;참고 및 추가 설명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;출처: https://www.acmicpc.net/problem/5582&lt;/li&gt;
  &lt;li&gt;추가 설명: https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%9E%A5&lt;em&gt;%EA%B3%B5%ED%86%B5&lt;/em&gt;%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>정수 배열에서 가장 큰 이어지는 원소들의 합을 구하라 - 시간복잡도는 O(n)</title>
        <link>/2018/03/01/find-max-sum-sequence.html</link>
        <guid isPermaLink="true">/2018/03/01/find-max-sum-sequence.html</guid>
        <description>&lt;ul&gt;
  &lt;li&gt;출처: 매일프로그래밍 #1&lt;/li&gt;
  &lt;li&gt;Longest increasing subsequence&lt;/li&gt;
  &lt;li&gt;이 문제는 최대 합을 구하기 위해 원소들을 계속 더해 나갈때 음의 원소가 나왔을 때 그 원소를 계속 더하는게 맞는지 아닌지를 판단하는 것이 중요하다&lt;/li&gt;
  &lt;li&gt;아래에서 currentMax는 원소들을 계속 더해 가면서 현재 인덱스에서의 최대 값을 의미한다&lt;/li&gt;
  &lt;li&gt;maxMax 값은 이제까지 나왔던 값들 중에서 최대 값을 의미하다. 즉, 중간에 음수 값이 나왔을때 이 값이 일시적으로 currentMax보다 커질수 있다&lt;/li&gt;
  &lt;li&gt;쉽지만, 헤맬수 있는 문제..&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: [-1, 3, -1, 5]
Output: 7 ( 3 + (-1) + 5 )

Input: [-5, -3, -1]
Output: -1 ( -1 )

Input: [2, 4, -2, -3, 8]
Output: 9 ( 2 + 4 + (-2) + (-3) + 8 )

int findMaxSum(const vector&amp;lt;int&amp;gt;&amp;amp; input) {

    int current_sum = 0;
    int max_sum = 0 ;
    for(int i = 0 ; i &amp;lt; input.size(); i++) {
        current_sum = max(current_sum + input[i], input[i]);
        max_sum = max(max_sum, current_sum);
    }
    return max_sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 -0800</pubDate>
      </item>
    
      <item>
        <title>정렬된 LinkedList를 BST로 변환하기</title>
        <link>/2018/02/28/longest-panlindrome-string.html</link>
        <guid isPermaLink="true">/2018/02/28/longest-panlindrome-string.html</guid>
        <description>&lt;ul&gt;
  &lt;li&gt;Given a string, find the longest substring which is palindrome. For example, if the given string is “forgeeksskeegfor”, the output should be “geeksskeeg”.&lt;/li&gt;
  &lt;li&gt;워낙 유명한 문제라.. 문제에 대한 설명은 생략한다&lt;/li&gt;
  &lt;li&gt;brute-force, dynamic programming 아니면 매 인덱스마다 좌우로 찾는 이 방법이 있다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;’’’
int getMaxLengthOfPanlindrome(const string&amp;amp; input, int low, int high, int maxLength, int&amp;amp; start) {
    int len = input.size();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (low &amp;gt;= 0 &amp;amp;&amp;amp; high &amp;lt; len &amp;amp;&amp;amp; input[low] == input[high])
{
    if (high - low + 1 &amp;gt; maxLength)
    {
        start = low;
        maxLength = high - low + 1;
        cout &amp;lt;&amp;lt; low &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; input[low] &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; high &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; input[high] &amp;lt;&amp;lt; endl;
    }
    --low;
    ++high;
}  
return maxLength;   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;int findLongestPanlindromeString(const string&amp;amp; input) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int maxLength = 1;  // The result (length of LPS)
int start = 0; 
 
for (int i = 1; i &amp;lt; input.size(); ++i)
{
    // 회문이 짝수인 경우
    int low = i - 1;
    int high = i;
    maxLength = getMaxLengthOfPanlindrome(input, low, high, maxLength, start);
 
    // 회문이 홀수인 경우
    low = i - 1;
    high = i + 1;
    maxLength = getMaxLengthOfPanlindrome(input, low, high,maxLength, start);
}
 
cout &amp;lt;&amp;lt; &quot;Longest palindrome substring is: &quot; &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; input.substr(start, start + maxLength - 1);
 
return maxLength;     } '''
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 -0800</pubDate>
      </item>
    
  </channel>
</rss>
