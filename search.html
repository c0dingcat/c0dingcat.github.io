<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | testcode</title>
	<meta name="description" content="daily log">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="testcode" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<link rel="stylesheet" href="http://blog.championswimmer.in/assets/css/pygments/solarized-light.css">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">testcode</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/tags.html">
					tags
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			









































            
            <!-- Search bar -->
            
		</ul>
	</nav>
    
</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2018-02-28-longest-panlindrome-string-html": {
        "title": "정렬된 LinkedList를 BST로 변환하기",
        "tags": "알고리즘, 회문, panlindrome",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "  Given a string, find the longest substring which is palindrome. For example, if the given string is “forgeeksskeegfor”, the output should be “geeksskeeg”.  워낙 유명한 문제라.. 문제에 대한 설명은 생략한다  brute-force, dynamic programming 아니면 매 인덱스마다 좌우로 찾는 이 방법이 있다.  ’’’int getMaxLengthOfPanlindrome(const string&amp; input, int low, int high, int maxLength, int&amp; start) {    int len = input.size();while (low &gt;= 0 &amp;&amp; high &lt; len &amp;&amp; input[low] == input[high]){    if (high - low + 1 &gt; maxLength)    {        start = low;        maxLength = high - low + 1;        cout &lt;&lt; low &lt;&lt; \", \" &lt;&lt; input[low] &lt;&lt; \", \" &lt;&lt; high &lt;&lt; \", \" &lt;&lt; input[high] &lt;&lt; endl;    }    --low;    ++high;}  return maxLength;   }int findLongestPanlindromeString(const string&amp; input) {int maxLength = 1;  // The result (length of LPS)int start = 0;  for (int i = 1; i &lt; input.size(); ++i){    // 회문이 짝수인 경우    int low = i - 1;    int high = i;    maxLength = getMaxLengthOfPanlindrome(input, low, high, maxLength, start);     // 회문이 홀수인 경우    low = i - 1;    high = i + 1;    maxLength = getMaxLengthOfPanlindrome(input, low, high,maxLength, start);} cout &lt;&lt; \"Longest palindrome substring is: \" &lt;&lt; endl;cout &lt;&lt; input.substr(start, start + maxLength - 1); return maxLength;     } '''",
        "url": "//2018/02/28/longest-panlindrome-string.html"
      }
      ,
    
      "2018-02-28-longest-increasing-sequence-html": {
        "title": "Longest Increasing Sequence",
        "tags": "",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/28/longest-increasing-sequence.html"
      }
      ,
    
      "2018-02-28-linkedlist-to-bst-html": {
        "title": "정렬된 LinkedList를 BST로 변환하기",
        "tags": "그래프, 알고리즘, BST, Linked List",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "  정렬된 linkedlist를 binary search 방식으로 BST로 변환한다  0~n개의 노드가 있을떄 중간 노드(n/2)의 값을 구하고 왼쪽 노드는 왼쪽 중간 노드를 구해서 (0~n/2의 중간값 n/4) 값을 설정한다  오른쪽 노드의 값은 n/2에서 n까지의 중간값을 구해서 설정하는 방식으로 재귀적으로 호출해서 BST를 완성한다.’’’tnode* llist_to_bst(lnode* head, lnode* tail) {if(head == nullptr)    return nullptr;lnode* fast_ptr = head;lnode* slow_ptr = slow;while(fast_ptr != nullptr &amp;&amp; fast_ptr != tail) {    fast_ptr = fast_ptr-&gt;next;    slow_ptr = slow_ptr-&gt;next;    if(fast_ptr!= nullptr &amp;&amp; fast_ptr != tail)        fast_ptr = fast_ptr-&gt;next;}tnode * ptr = new tnode(slow_ptr-&gt;value);ptr-&gt;left = llist_to_bst(head, slow_ptr);ptr-&gt;right = llist_to_bst(slow_ptr-&gt;next, tail);return ptr; } '''",
        "url": "//2018/02/28/linkedlist-to-bst.html"
      }
      ,
    
      "2018-02-28-find-biggest-bst-html": {
        "title": "아주 큰 트리에서 가장 큰 BST 찾기",
        "tags": "그래프, 알고리즘, BST, Linked List",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "  문제: You are given a very large binary tree, return the root node of the largest BST in the given tree  왼쪽, 오른쪽 순환하면서 BST 조건에 맞는 노드를 찾기 시작한다  왼쪽 노드```int find_biggest_bst(node* ptr, int&amp; min, int &amp;max, int&amp; total_nodes, node*&amp; head) {    if(!ptr)        return 0;int left = find_biggest_bst(ptr, min, max, total_nodes, head);int current_min = (left ==0)?ptr-&gt;value: min;if((left==-1) || (left != 0 &amp;&amp; ptr-&gt;value &gt; max)) {    return -1;}int right = find_biggest_bst(ptr, min, max, total_nodes, head);int current_max = (right == 0)? ptr-&gt;value:max;if(right == -1 || (right != 0 &amp;&amp; ptr-&gt;value &lt; min)) {    return -1;}int total = left + right + 1;current_min = min;current_max = max;if(total_nodes &lt; total) {    total_ndoes = total;}return total; } '''",
        "url": "//2018/02/28/find-biggest-bst.html"
      }
      ,
    
      "2018-02-28-convert-bst-to-double-linked-list-html": {
        "title": "Convert Bst To Double Linked List",
        "tags": "",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "layout: posttitle: BST를 Double Linked List로 변환하기tags: [그래프,알고리즘, BST, Linked List]—  왼쪽 노드를 계속 순환해서 최소값이 될때까지 순환한다  최소값이 되면, 그 노드의 값을 헤드값으로 저장하고 부모노드 및 오른쪽 노드를 계속 추가해서 리스트를 만든다  노드를 추가할때 현재 노드의 이전 노드 값이 prev값과 동일한지 확인할 필요가 있다.’’’struct node {    node(int n): value(n){}    int value;    node* left, * right;};void insert_before(node* prev, node* current) {    node* temp = current-&gt;left;    if(prev) {        cout « “prev - n: “ « prev-&gt;value « endl;        prev-&gt;right = current;        prev-&gt;left = temp;    }if(temp &amp;&amp; temp != prev) {    cout &lt;&lt; \"temp-n: \" &lt;&lt; temp-&gt;value &lt;&lt; endl;    temp-&gt;right = prev;    }cout &lt;&lt; \"after prev, temp\" &lt;&lt; endl;current-&gt;left = prev; }void bst_to_ddl(node* ptr, node&amp; prev, node&amp; head, int&amp; min) {    if(!ptr)        return;bst_to_ddl(ptr-&gt;left, prev, head, min);insert_before(prev, ptr);prev = ptr;if(ptr-&gt;value &lt; min) {    cout &lt;&lt; \"min: \" &lt;&lt; ptr-&gt;value &lt;&lt; endl;    min = ptr-&gt;value;    head = ptr;}bst_to_ddl(ptr-&gt;right, prev, head, min); }int main() {    node* root_ptr = new node(4);    root_ptr-&gt;left = new node(2);    root_ptr-&gt;right = new node(5);    root_ptr-&gt;left-&gt;right = new node(3);    root_ptr-&gt;left-&gt;left = new node(1);int min = 100;node* prev_ptr = nullptr;node* head_ptr;bst_to_ddl(root_ptr, prev_ptr, head_ptr, min);node* current_ptr = head_ptr;while(current_ptr) {    cout &lt;&lt; current_ptr-&gt;value &lt;&lt; endl;    current_ptr = current_ptr-&gt;right;} } '''",
        "url": "//2018/02/28/convert-bst-to-double-linked-list.html"
      }
      ,
    
      "2018-02-26-ed-81-ac-eb-a3-a8-ec-8a-a4-ec-b9-bc-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "크루스칼 알고리즘",
        "tags": "그래프, 알고리즘, 크루스칼",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  크루스칼 알고리즘  edge의 cost별로 정렬한다  하나씩 빼서 cycle을 만드는지 확인한다  사이클을 만들지 않는 edge들만 뽑아서 리턴한다  상당히 간단하다  사이클을 만드는데 사용하는 disjoined_set 알고리즘은 간단하지만 효과적이다  시간 복잡도는 모든 edge에 대해 정렬하기 때문에 O(ElogE)  disjoined set의 경우는 시간복잡도가 ELogE보다 작기 때문에, 정렬하는데 드는 시간이 driving forceusing namespace std;struct edge {    int u,v,cost;    edge(int u1, int v1, int c):u(u1), v(v1), cost(c) {}    bool operator &lt; (const edge&amp; e) {        return cost &lt; e.cost;    }};struct disjoined_set {    map&lt;int,int&gt; parent;    void init(vector&lt;edge&gt;&amp; edges) {        for(auto e : edges) {            if(!parent.count(e.u))                parent.insert(make_pair(e.u, e.u));                        if(!parent.count(e.v))                parent.insert(make_pair(e.v, e.v));        }    }        int find_parent(int u) {        if(parent[u] == u)            return u;        cout &lt;&lt; \"u: \" &lt;&lt; u &lt;&lt; \", u_parent: \" &lt;&lt; parent[u] &lt;&lt; endl;                return parent[u] = find_parent(parent[u]);    }        bool same_set(int u, int v) {        cout &lt;&lt; \"before same_set\" &lt;&lt; endl;        if(find_parent(u) == find_parent(v))            return true;                cout &lt;&lt; \"false\" &lt;&lt;endl;        return false;    }        void merge(int u, int v){        int u_parent = find_parent(u);        int v_parent = find_parent(v);        cout &lt;&lt; \"u_parent: \" &lt;&lt; u_parent &lt;&lt; \", v_parent: \" &lt;&lt; v_parent &lt;&lt; endl;        if(u_parent == v_parent)            return;                parent[v_parent] = u_parent;                }};vector&lt;edge&gt; kruskal(vector&lt;edge&gt;&amp; input) {    sort(input.begin(), input.end());    vector&lt;edge&gt; output;    disjoined_set ds;    ds.init(input);        for(auto e : input) {        cout &lt;&lt; \"edge u: \" &lt;&lt; e.u &lt;&lt; \", v: \" &lt;&lt; e.v &lt;&lt; \", cost: \" &lt;&lt; e.cost &lt;&lt;endl;        if(!ds.same_set(e.u, e.v)) {            cout &lt;&lt; \"ds.same_set \" &lt;&lt; endl;            output.push_back(e);            ds.merge(e.u, e.v);        }    }    cout &lt;&lt; \"output\" &lt;&lt; endl;    return output;}int main() {    edge e1(1,3,4);    edge e2(1,2,5);    edge e3(2,3,2);    edge e4(2,4,7);    edge e5(3,4,6);    edge e6(3,5,11);    edge e7(4,5,3);    edge e8(4,6,8);    edge e9(5,6,8);    vector&lt;edge&gt; edges = {e1,e2,e3,e4,e5,e6,e7,e8,e9};    vector&lt;edge&gt; output = kruskal(edges);        for(edge e : output)        cout &lt;&lt; \"edge u: \" &lt;&lt; e.u &lt;&lt; \", v: \" &lt;&lt; e.v &lt;&lt; \", cost: \" &lt;&lt; e.cost &lt;&lt;endl;}",
        "url": "//2018/02/26/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "2018-02-26-ec-82-ac-ec-9d-b4-ed-81-b4-ec-b2-b4-ed-81-ac-html": {
        "title": "사이클 체크",
        "tags": "그래프, 알고리즘, 사이클",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  사이클 확인 알고지름  DFS 방식을 활용해서 사이클이 있는지 확인한다  현재 순환중이면 상태를 VISTING으로 변경해서 순환이 끝나지 않았음에도 불구하고 다시 체크하러 오는지 확인하다  현재 노드들을 순환중인데도 불구하고 다시 확인하러 오면 사이클이 있음  시간 복잡도는 O(E+V)using namespace std;enum STATUS {  NOT_VISITED,    VISITING,    VISITED};bool hasCycle(map&lt;int,vector&lt;int&gt;&gt;&amp; input,             map&lt;int, int&gt;&amp; visited,             int here) {    if(visited[here] == VISITING){        cout &lt;&lt; here &lt;&lt; \" confirmed visiting\" &lt;&lt; endl;        return true;    }    else if(visited[here] == VISITED)        return false;        visited[here] = VISITING;    cout &lt;&lt; here &lt;&lt; \" visiting \" &lt;&lt; endl;        for(int there : input[here]) {        cout &lt;&lt; there &lt;&lt; \" checking \" &lt;&lt; endl;        if(hasCycle(input, visited, there))            return true;    }    visited[here] = VISITED;    return false;}void process(const vector&lt;vector&lt;int&gt;&gt;&amp; input, map&lt;int, vector&lt;int&gt;&gt;&amp; output){    for(auto entry : input) {        int u = entry[0];        int v = entry[1];                    if(!output.count(u)) {            vector&lt;int&gt; vec = { v };            output.insert(make_pair(u, vec));        }        else {            output[u].push_back(v);        }    }}int main() {    vector&lt;vector&lt;int&gt;&gt; input = {        {1,2},        {1,3},        {2,3},        {3,4},        {2,4},        {3,5},        {4,5},        {4,6},        {5,6},    };        map&lt;int, vector&lt;int&gt;&gt; source;    process(input, source);    map&lt;int,int&gt; visited;    for(auto kvp : source)        visited.insert(make_pair(kvp.first,0));    bool cycle = hasCycle(source, visited, 1);    cout &lt;&lt; \"cycle: \" &lt;&lt; cycle &lt;&lt; endl;}",
        "url": "//2018/02/26/%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%B2%B4%ED%81%AC.html"
      }
      ,
    
      "2018-02-26-permutation-html": {
        "title": "Permutation",
        "tags": "",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/26/permutation.html"
      }
      ,
    
      "2018-02-26-max-diameter-of-tree-html": {
        "title": "트리의 최장 직경 구하기",
        "tags": "트리, 알고리즘",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  어느 한 노드가 있을 경우 최장 직경은..  왼쪽에서 가장 큰 height와 오른쪽에서 가장 큰 height에 1을 더한 값과  왼쪽에서의 가능 큰 직경, 오른쪽에서의 가장 큰 직경  이 세 값 중에서 가장 큰 값을 고르면 된다struct node {    node* left, *right};int height(node* ptr) {    if(!ptr)        return 0;        int lh = height(ptr-&gt;left);    int rh = height(ptr-&gt;right);    return 1 + max(lh, rh);}int diameter(node* ptr) {    if(!ptr)        return 0;        int lh = height(ptr-&gt;left);    int rh = height(ptr-&gt;right);    int ld = diameter(ptr-&gt;left);    int rd = diameter(ptr-&gt;right);    return max(1+lh+rh, max(ld,rd));}",
        "url": "//2018/02/26/max-diameter-of-tree.html"
      }
      ,
    
      "2018-02-26-find-largest-bst-html": {
        "title": "Find Largest Bst",
        "tags": "",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/26/find-largest-bst.html"
      }
      ,
    
      "2018-02-26-connect-all-the-nodes-html": {
        "title": "섬의 개수 세기",
        "tags": "그래프, 알고리즘",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  next 노드를 구하기 위해서는 부모노드의 next를 타고 가서 왼쪽 노드가 있는지 확인한다 없으면 오른쪽 노드  왼쪽 오른쪽 자식 노드가 존재하지 않으면 또 부모 노드의 옆의 노드로 가서 위와 동일하게 반복한다  횡으로 탐색이 끝나면, 다음 자식 노드로 내려가기 위해서 왼쪽 자식 노드 혹은 오른쪽 자식 노드의 값을 사용해서 동일하게 옆의 노드를 체크한다struct node {    int n;    node* left, * right, * next;};node* findNext(node* ptr) {    node* next = ptr-&gt;next;    while(next) {        if(next-&gt;left)            return next-&gt;left;        if(next-&gt;right)            return next-&gt;right;        next  = next-&gt;next;    }    return next;};void connectNext(node* ptr) {        node* level_ptr = ptr;        while(level_ptr) {        node * current = level_ptr;             while(current) {            if(current-&gt;left)                current-&gt;left-&gt;next = (!current-&gt;right) ? current-&gt;right: findNext(current);                        if(current-&gt;right)                current-&gt;right = findNext(current);            current = current-&gt;next;        }                    if(level_ptr-&gt;left)            level_ptr = level_ptr-&gt;left;        else        if(level_ptr-&gt;right)            level_ptr = level_ptr-&gt;right;    }}",
        "url": "//2018/02/26/connect-all-the-nodes.html"
      }
      ,
    
      "2018-02-25-number-of-islands-html": {
        "title": "Number Of Islands",
        "tags": "",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/25/number-of-islands.html"
      }
      ,
    
      "2018-02-25-longest-substring-without-repeating-characters-html": {
        "title": "Longest substring without repeating characters",
        "tags": "LST, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "##출처:  https://leetcode.com/problems/longest-substring-without-repeating-characters/description/문제  Given a string, find the length of the longest substring without repeating characters.    Examples:Given \"abcabcbb\", the answer is \"abc\", which the length is 3.Given \"bbbbb\", the answer is \"b\", with the length of 1.Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.      분석  Sliding Window 방식을 사용한다  큐에 캐릭터를 집어 넣는다  반복된 문자가 나오면, 지금까지 쌓아놓았던 문자의 수를 기억한다  큐에서 문자를 계속 poping한다. 새로 집어 넣으려고 하는 문자와 동일한 문자가 나올때까지  반복되는 문자가 발견되면, 다시 카운트를 시작한다  O(N)으로 해결 가능코드class Solution {public:    int popAndCount(char c, vector&amp; bvec, queue&amp; cqueue) {        auto size = cqueue.size();        while(!cqueue.empty() &amp;&amp; cqueue.front() != c) {            bvec[cqueue.front()] = false;            cqueue.pop();        }        if(cqueue.front() == c) {            bvec[c] = false;            cqueue.pop();        }                  return size;            }        int lengthOfLongestSubstring(string input) {        queue cqueue;        vector bvec(128);        auto maxValue = 0 ;                 for(auto i = 0; i &lt; input.length(); i++) {               char c = input[i];                if(bvec[c]) {                auto count = popAndCount(c, bvec, cqueue);                maxValue = std::max(maxValue, count);            }            cqueue.push(c);            bvec[c] = true;        }                if(!cqueue.empty()) {            auto count = 0;            while(!cqueue.empty()) {                count++;                cqueue.pop();            }            maxValue = std::max(maxValue, count);        }        return maxValue;        }};",
        "url": "//2018/02/25/longest-substring-without-repeating-characters.html"
      }
      ,
    
      "2018-02-25-light-is-failing-to-the-left-side-of-tree-html": {
        "title": "빛은 트리의 왼쪽에 떨어진다",
        "tags": "트리, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "Light is falling on a tree from left side you have to find all the nodes on which this light will fall.  일반적인 트리 문제  왼쪽에서만 보이는 트리들을 필터링해서 보여주면 된다코드struct node {    int value;    node* left, *right;};void filter_nodes_from_leftside(node* ptr, const int level, int&amp; max_level) {    if(!ptr)        return;        if(level &gt; max_level) {        max_level = level;        cout &lt;&lt; ptr-&gt;value &lt;&lt; endl;    }    filter_nodes_from_leftside(ptr-&gt;left, level+1, max_level);    filter_nodes_from_leftside(ptr-&gt;right, level+1, max_level);}",
        "url": "//2018/02/25/light-is-failing-to-the-left-side-of-tree.html"
      }
      ,
    
      "2018-02-25-disjoined-set-html": {
        "title": "디스조인트 셋",
        "tags": "그래프, 디스조인트",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "출처  https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0  https://ratsgo.github.io/data%20structure&amp;algorithm/2017/11/12/disjointset/  http://js1jj2sk3.tistory.com/m/category/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Disjoint-set%20%EB%94%94%EC%8A%A4%EC%A1%B0%EC%9D%B8%ED%8A%B8-%EC%85%8B  http://bowbowbow.tistory.com/26설명  서로 중복되지 않은 부분집합들로 나누워진 정보들을 저장  set A, set B: B가 A의 모든 요소를 포함하는 경우: A = subset of B, B = superset of A  set A, set B: A와 B가 공유하는 원소가 없다면: A와 B는 mutually disjoint  임의의 셋을 분할(partition): 서로 중복되는 원소가 없도록 셋을 나눔  분할된 셋들을 합치면 원래의 셋으로 복원연산  make-set(x): 초기화 연산, x를 유일한 요소로 하는 셋을 만듬  union(x,y): x가 속한 셋과 y가 속한 셋을 합침  셋들을 합칠때에는 대표값들을 서로 연결해 줌  set A (3) (3&lt;-4), set B (1) (1&lt;-2)  untion(A,B)(3) (2-&gt;1-&gt;3&lt;-4)  find(x): x가 속한 셋의 대표값(루트노드 값)을 반환find 연산  구조에 따라서 여러가지 방법으로 find가 가능하지만..  재귀적인 방식으로 find 연산을 구현한 방식을 표현하면..      선형시간으로 탐색이 가능    function find(x)  if x.parent != x:      x.parent = Find(x.parent)  return x.parent      union 연산      두 셋의 대표들을 찾아 연결해 주면 된다.    function union(x,y):  xRoot = find(x)  yRoot = find(y)  yRoot.parent = xRoot      일반적인 set collection과의 비교  일반적인 stl에서 구현된 set의 경우 BST 구조를 가져서, 일반적인 연산의 경우 log의 시간을 가진다  disjoint set은 노드에 parent 하나만 추가해서 선형적인 시간에 값을 가져올 수 있음struct disjoined_set {    map&lt;char, char&gt; parent;    void init_set(vector&lt;char&gt; vertext) {        for(auto ch : vertext)            parent.insert(make_pair(ch,ch));    }        char find_parent(char ch) {        if(find_parent(ch) == ch)            return ch;                return parent[ch] = find_parent(parent[ch]);    }        bool same_set(char c1, char c2) {        char c1_parent = find_parent(c1);        char c2_parent = find_parent(c2);                if(c1_parent == c2_parent)            return true;        return false;    }        void merge(char c1, char c2) {        if(same_set(c1, c2))            return;                parent[c2_parent] = c1_parent;    }}",
        "url": "//2018/02/25/disjoined-set.html"
      }
      ,
    
      "2018-02-25-diameter-of-tree-html": {
        "title": "Diameter of tree - 트리의 직경",
        "tags": "트리, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "  트리의 직경은 가장 크게 떨어진 두 개의 노드 사이에 있는 노드들의 개수를 의미한다  트리의 직경을 구할때 트리의 height와의 비교도 필요하다코드int height(node* ptr) {    if(!ptr)        return 0;    return 1 + max(height(ptr-&gt;left), height(ptr-&gt;right));}int diameter(node *ptr) {        if(!ptr)        return 0;        int lheight = height(ptr-&gt;left);    int rheight = height(ptr-&gt;right);    int left = diameter(ptr-&gt;left);    int right = diameter(ptr-&gt;right);        return max(lheight + rheight +1, max(left, right));   }",
        "url": "//2018/02/25/diameter-of-tree.html"
      }
      ,
    
      "2018-02-25-lca-html": {
        "title": "Lowest Common Ancestor",
        "tags": "트리, LCA, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "출처  http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/분석  트리를 DFS 방식으로 재귀호출한다  비교 해야 하는 두 값이 n1,n2라고 가정한다  만약 노드의 값이 n1, n2와 동일하면, 그 노드가 LCA  왼쪽과 오른쪽 노드의 값을 재귀호출로 검사  왼쪽 트리에서 n1의 값이 발견되고, 오른쪽에 n2가 발견되면 그 서브트리의 루트가 LCA  왼쪽에서 n1,n2 값이 발견되면 왼쪽을 검사해서 LCA 리턴코드class node {public:      int val;      node* left_ptr;      node* right_ptr:};node* findLCA(node* tree_ptr, int n1, int n2){      if(tree_ptr-&gt;val == n1 || tree_ptr-&gt;val == n2)          return tree_ptr;      node* left_ptr = findLCA(tree_ptr-&gt;left, n1,n2);      node* right_ptr = findLCA(tree_ptr-&gt;right,n1,n2);      if(left_ptr &amp;&amp; right_ptr)         return tree_ptr;      return (left_ptr!=NULL)?left_ptr:right_ptr;}",
        "url": "//2018/02/25/LCA.html"
      }
      ,
    
      "2018-02-25-clone-a-tree-with-random-pointer-html": {
        "title": "Clone a binary tree with random pointers",
        "tags": "트리, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "  Clone a Binary Tree with Random Pointers  Given a Binary Tree where every node has following structure.  The random pointer points to any random node of the binary tree and can even point to NULL, clone the given binary tree.관찰  쉽게 할 수 있는 방법은 map을 사용하는 방식  노드 하나를 추가할때 마다 이전 노드의 키와 새로 생성한 노드의 주소를 맵에 추가한다  트리 생성이 완료되면 한바퀴 트리를 순회하면서 메모리 주소를 맵에서 꺼내서 업데이트 한다코드  맵 혹은 해시 테이블을 사용할 경우는 특별한 부분이 없다  트리를 순회하면서 노드들을 복사하고, 기존에 있던 노드 값과 그에 대응되어 생긴 노드의 주소 값을 맵에 넣는다  복사가 끝나면, 다시 한 번 순회해서 random 포인터를 새로 생긴 노드 값으로 업데이트 한다struct node{    int value;    node* left, *right, *random;    node(int n, node* rand):value(n),random(rand){}};void copy_node(node* ptr_src,                node* ptr_dst,                map&lt;node*, node*&gt;&amp; mem_table) {    if(ptr_src == nullptr)        return;        if(ptr_src-&gt;left) {        ptr_dst-&gt;left = new node(ptr_src-&gt;left-&gt;value, ptr_src-&gt;left-&gt;random);        mem_table.insert(make_pair(ptr_src-&gt;left, ptr_dst-&gt;left));        copy_node(ptr_src-&gt;left, ptr_dst-&gt;left, mem_table);    }        if(ptr_src-&gt;right) {        ptr_dst-&gt;right = new node(ptr_src-&gt;right-&gt;value, ptr_src-&gt;right-&gt;random);        mem_table.insert(make_pair(ptr_src-&gt;right, ptr_dst-&gt;right));        copy_node(ptr_src-&gt;right, ptr_dst-&gt;right, mem_table);    }}void update_random_ptr(node* ptr_src, node* ptr_dst, map&lt;node*,node*&gt;&amp; mem_table) {        if(ptr_src == nullptr)        return;        if(ptr_src-&gt;left)        update_random_ptr(ptr_src-&gt;left,  ptr_dst-&gt;left, mem_table);        if(ptr_dst-&gt;random)        ptr_dst-&gt;random = mem_table[ptr_src-&gt;random];        if(ptr_src-&gt;right)        update_random_ptr(ptr_src-&gt;right, ptr_dst-&gt;right, mem_table);}node* clone_tree(node* ptr) {        node* clone_ptr = new node(ptr-&gt;value, ptr-&gt;random);    node* pos_ptr = ptr;    map&lt;node*, node*&gt; mem_table;    copy_node(ptr, clone_ptr, mem_table);    update_random_ptr(ptr, clone_ptr, mem_table);    return clone_ptr;    }",
        "url": "//2018/02/25/Clone-A-Tree-With-Random-Pointer.html"
      }
      ,
    
      "2018-02-24-ed-94-84-eb-a6-bc-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "프림 알고리즘",
        "tags": "알고리즘, 프림, 그래프, 최소거리",
        "date": "February 24, 2018",
        "author": "",
        "category": "",
        "content": "  최소 신장 트리를 구하는데 사용한다  정점을 선택하고 DST와 약간은 유사하게 인접한 정점들의 최소 값을 구해서 트리에 추가한다  minimum priority queue에 인접한 vertex와 cost 정보를 넣는다  최소 cost를 가지는 vertex 정보를 뽑아온다  이미 방문했는지 확인하다  방문 안했으면 인접한 노드들을 queue에 다시 집어 넣는다  최소 값 기준으로 계속 값을 가져와서 스패닝 트리를 만든다  이때 시간 복잡도는 인접 해렬, 검색의 경우는 V^2  이진 힙 및 인접리스트 O((V+E)logV)=ElogV코드struct edge {    int cost, vertex;    edge(int v, int c):vertex(v), cost(c){} };struct less_comp {    bool operator()(const edge&amp; e1, const edge&amp; e2) {        return e1.cost &gt; e2.cost;    }};vector&lt;edge&gt; prim(map&lt;int, vector&lt;edge&gt;&gt;&amp; input, int start) {    priority_queue&lt;edge, vector&lt;edge&gt;, less_comp&gt; que;    map&lt;int, bool&gt; selected;        edge s(start,0);    que.push(s);        vector&lt;edge&gt; output;    int cost = 0 ;        while(!que.empty()) {        edge adjacent = que.top(); que.pop();                int here = adjacent.vertex;                if(selected[here]) {            continue;        }                selected[here] = true;                output.push_back(adjacent);                for(auto e : input[here]) {            que.push(e);        }    }    return output;}void process(const vector&lt;vector&lt;int&gt;&gt;&amp; input, map&lt;int, vector&lt;edge&gt;&gt;&amp; output){    for(auto entry : input) {        int u = entry[0];        int v = entry[1];        int c = entry[2];        edge e1(v,c);                    if(!output.count(u)) {            vector&lt;edge&gt; vec = { e1 };            output.insert(make_pair(u, vec));        }        else {            output[u].push_back(e1);        }    }}int main() {    vector&lt;vector&lt;int&gt;&gt; input = {        {1,2,5},        {2,1,5},        {1,3,4},        {3,1,4},        {2,3,2},        {3,2,2},        {3,4,6},        {4,3,6},        {2,4,7},        {4,2,7},        {3,5,11},        {5,3,11},        {4,5,3},        {5,4,3},        {4,6,8},        {6,4,8},        {5,6,8},        {6,5,8}    };        map&lt;int, vector&lt;edge&gt;&gt; output;    process(input, output);    vector&lt;edge&gt; result = prim(output,1);        for(auto e : result)        cout &lt;&lt; \"v: \" &lt;&lt; e.vertex &lt;&lt; \", cost: \" &lt;&lt; e.cost &lt;&lt; endl;}",
        "url": "//2018/02/24/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "2018-02-24-eb-8b-a4-ec-9d-b5-ec-8a-a4-ed-8a-b8-eb-9d-bc-html": {
        "title": "다익스트라 소스",
        "tags": "알고리즘, 다익스트라, 그래프, 최소거리",
        "date": "February 24, 2018",
        "author": "",
        "category": "",
        "content": "  처음 vertex에서 시작한다  정점에 인접한 정점들과 거리를 우선순위 큐에 넣는다  거리순으로 오름차순 정렬해서 기존에 알려진 최소거리와 비교한다  만약 기존에 알려진 최소거리보다 작으면 기존의 최소거리를 업데이트한다  목적지에 도착할때까지 계속 반복한다#include &lt;iostream&gt;struct adjacent {    int v, cost;    adjacent(int v1, int c):v(v1),cost(c){}    bool operator&lt;(const adjacent&amp; adj) {        return cost &lt; adj.cost;    }};struct less_comp_functor{    bool operator()(const adjacent&amp; lhs, const adjacent&amp; rhs) {        return lhs.cost &gt; rhs.cost;    }};int get_or_default(map&lt;int, int&gt;&amp; dists, int v) {    const int INF = 0x7fffffff;        if(!dists.count(v))        dists.insert(make_pair(v,INF));        return dists[v];   }map&lt;int,int&gt; djkstra(map&lt;int, vector&lt;adjacent&gt;&gt;&amp; input, int start) {    map&lt;int,int&gt; dists;    priority_queue&lt;adjacent, vector&lt;adjacent&gt;, less_comp_functor&gt; que;    adjacent adj(start,0);    que.push(adj);        while(!que.empty()) {                adjacent adj = que.top(); que.pop();        int cost = adj.cost;        int v = adj.v;                cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; \", cost: \" &lt;&lt; cost &lt;&lt; endl;                if(get_or_default(dists,v) &gt; cost)            dists[v] = cost;                for(auto a : input[v]) {            int there = a.v;            int new_cost = dists[v] + a.cost;                    if(get_or_default(dists, there) &gt; new_cost){                dists[there] = new_cost;                a.cost = new_cost;                que.push(a);            }                    }    }    return dists;    }int main() {    vector&lt;adjacent&gt; vec1 = {adjacent(2,10), adjacent(3,30), adjacent(4,15)};    vector&lt;adjacent&gt; vec2 = {adjacent(3,5), adjacent(6,20)};    vector&lt;adjacent&gt; vec3 = {adjacent(5,20)};    vector&lt;adjacent&gt; vec4 = {adjacent(6,20)};    vector&lt;adjacent&gt; vec5 = {adjacent(6,5)};    vector&lt;adjacent&gt; vec6 = {adjacent(4,20)};        map&lt;int, vector&lt;adjacent&gt;&gt; input = {        {1,vec1},        {4,vec2},        {2,vec3},        {5,vec4},        {3,vec5},        {6,vec6}             };        auto output = djkstra(input,1);        for(auto o : output) {        cout &lt;&lt; o.first &lt;&lt; \", \" &lt;&lt; o.second &lt;&lt; endl;    }    }",
        "url": "//2018/02/24/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC.html"
      }
      ,
    
      "2018-02-17-median-value-of-bst-html": {
        "title": "median valud of BST",
        "tags": "알고리즘, 다익스트라, 그래프, 최소거리",
        "date": "February 17, 2018",
        "author": "",
        "category": "",
        "content": "문제Given a Binary Search Tree, find median of it. If no. of nodes are even: then median = ((n/2th node + (n+1)/2th node) /2 If no. of nodes are odd : then median = (n+1)th node. For example, median of below BST is 12. 분석  O(N)으로 풀기 위해서는 정상적으로 트리를 순환하는 방식을 사용해야 한다  Median 값을 찾기 위해서는 현재 몇번째 노드를 순환하는지를 알아야 한다  현재 순환한 노드 값이 중간 값인지를 파악하기 위해서는 전체 노드의 수를 알아야 한다  후위 혹은 전위로 순환하면서 방문한 노드이 수를 파악한다  노드의 수가 전체 노드의 중간이며 Median 값을 구한다코드  현재 방문하고 있는 노드의 수를 잘 세는 것이 필요하다class node { public:     node(int n):val(n) {}     int val;     node* left;     node* right;  };int count(node* ptr) {     return (!ptr)?0:1 + count(ptr-&gt;left) + count(ptr-&gt;right);  }int median(node* ptr, int total, int&amp; pos) {    if(!ptr)        return 0;    int right = median(ptr-&gt;right, total, pos);    pos++;    if(pos == total/2 &amp;&amp; total%2 == 0)         return (ptr-&gt;val + ptr-&gt;right-&gt;val)/2;    if(pos == (total/2+1) &amp;&amp; total%2==1)        return ptr-&gt;val;    int left = median(ptr-&gt;left, total, pos);    return right + left;}int main() {     node* root = new node(20);    root-&gt;right = new node(22);    root-&gt;left = new node(8);    root-&gt;left-&gt;left = new node(4);    root-&gt;left-&gt;right = new node(12);    root-&gt;left-&gt;right-&gt;left = new node(10);    root-&gt;left-&gt;right-&gt;right = new node(14);    int pos = 0;    int c = count(root);    int m = median(root, c, pos);    cout &lt;&lt; \"count: \" &lt;&lt; c &lt;&lt; \", \" &lt;&lt; c/2 &lt;&lt; \", m: \" &lt;&lt; m &lt;&lt; endl;}",
        "url": "//2018/02/17/median-value-of-bst.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.7.1/lunr.min.js"></script>
<script src="/assets/js/search.js"></script>
</section>
</article>

    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
