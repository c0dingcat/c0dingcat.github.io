<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | c0dingcat</title>
	<meta name="description" content="daily log">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="c0dingcat" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<link rel="stylesheet" href="http://blog.championswimmer.in/assets/css/pygments/solarized-light.css">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/ohhocat.jpg" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">c0dingcat</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/tags.html">
					tags
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			









































            
            <!-- Search bar -->
            
		</ul>
	</nav>
    
</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2018-03-04-ed-8e-9c-ec-9c-85-ed-8a-b8-eb-a6-ac-html": {
        "title": "펜윅트리 - 빠르고 간단한 구간 합",
        "tags": "자료구조, 펜윅트리, Segment Tree, 구간합",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "펜윅트리 (Fenwick)  구간합을 구하는데 특화된 간략화된 segement tree  segment tree가 미리 계사해 저장하는 정보의 상당수가 필요 없게됨  http://www.crocus.co.kr/666 설명 참조using namespace std;int sum(vector&lt;int&gt; &amp;tree, int i) {    int ans = 0;    while (i &gt; 0) {        ans += tree[i];        i -= (i &amp; -i);    }    return ans;}void update(vector&lt;int&gt; &amp;tree, int i, int diff) {    while (i &lt; tree.size()) {        tree[i] += diff;        i += (i &amp; -i);    }}int main() {    int n, m, k;    scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;k);    vector&lt;int&gt; a(n+1);    vector&lt;int&gt; tree(n+1);    for (int i=1; i&lt;=n; i++) {        scanf(\"%lld\",&amp;a[i]);        update(tree, i, a[i]);    }    m += k;    while (m--) {        int t1;        scanf(\"%d\",&amp;t1);        if (t1 == 1) {            int t2;            int t3;            scanf(\"%d %d\",&amp;t2,&amp;t3);            int diff = t3-a[t2];            a[t2] = t3;            update(tree, t2, diff);        } else {            int t2,t3;            scanf(\"%d %d\",&amp;t2,&amp;t3);            printf(\"%d\\n\",sum(tree, t3) - sum(tree, t2-1));        }    }    return 0;}",
        "url": "//2018/03/04/%ED%8E%9C%EC%9C%85%ED%8A%B8%EB%A6%AC.html"
      }
      ,
    
      "2018-03-04-ec-a0-91-eb-af-b8-ec-82-ac-eb-b0-b0-ec-97-b4-eb-a7-a8-eb-b2-84-eb-a7-88-ec-9d-b4-ec-96-b4-ec-8a-a4-html": {
        "title": "접미사 배열 - 맨버-마이너스 알고리즘",
        "tags": "알고리즘, 접미사 배열, 맨버-마이너스",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "접미사 배열  접미사 배열의 길이는 항상 H이므로 문자열 탐색 시에 접미사 배열 내부의 아이템을 찾는 시간은 logH, 문자열 검색에 N  그래서 시간 복잡도는 O(NlogH)접미사 배열 생성 - 단순한 알고리즘    struct comparator {        const string&amp; source;        comparator(const string&amp; s):source(s){}        bool operator()(int i, int j) {            return strcmp(source.c_str()+1, source.c_str() + j) &lt; 0 ;        }    }    vector&lt;int&gt; getSuffixArray(const string &amp; source){        vector&lt;int&gt; output;        for(int i = 0 ; i &lt; source.size(); i++) {            output.push_back(i);        }        sort(output.begin(), output.end(), comparator(source));        return output;    }  시간복잡도: 문자열 비교에 N, 정렬에 NlogN, 시간복잡도: O(N2logN)맨버-마이어스 알고리즘  접미사 목록을 여러번에 걸쳐서 정렬  처음에는 한글자 기준, 다음에는 두 글자 기준, .. 등등으로 여러번에 걸쳐서 정렬함",
        "url": "//2018/03/04/%EC%A0%91%EB%AF%B8%EC%82%AC-%EB%B0%B0%EC%97%B4-%EB%A7%A8%EB%B2%84-%EB%A7%88%EC%9D%B4%EC%96%B4%EC%8A%A4.html"
      }
      ,
    
      "2018-03-04-ec-98-a8-eb-9d-bc-ec-9d-b8-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "외계 신호 분석 - 온라인 알고리즘",
        "tags": "알고리즘, 온라인 알고리즘",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  알고리즘 문제해결 전력 19.6 - 외계신호 분석  신호 생성 방식 A[0] = 1983, A[i] = (A[i-1]*214013+2531011) mod 232  슬라이딩 윈도우 기법으로 한꺼번에 많은 메모리를 할당하지 않고, 바로 합이 k가 되는 숫자들을 구하고 있음코드struct asig {    unsigned seed;    asig():seed(1983){}    unsinged next() {        unsigned ret = seed;        seed = ((seed*214013u)+2531011u);        return ret % 1000 + 1;    }}int countRanges(int k, int n) {    asig sig_;    queue&lt;int&gt; range;    int ret = 0, rangeSum = 0;    for(int i = 0 ;  i &lt; n ; i++) {        int new_sig = sig_.next();        rangeSum += new_sig;        range.push(new_sig);        while(rangeSum &gt;k){            rangeSum -= range.front(); range.pop();        }        if(rangeSum == k) ret++;    }    return ret;}",
        "url": "//2018/03/04/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "2018-03-04-ec-86-8c-eb-b0-a9-ec-b0-a8-html": {
        "title": "소방차",
        "tags": "그래프, 알고리즘, 다익스트라, 최소거리",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  서울 시내에 m개의 소방서가 있습니다.  화재 장소에서 가장 가까운 소방서에서 소방차를 보낸다고 할 때, 각 화재 장소에 소방차가 도달하기까지 걸리는 시간의 합을 계산하는 프로그램을 작성하세요  “예제 지도를 봅시다. 사각형으로 표시된 지점들은 소방서를, 음영으로 칠해진 지점들은 불이 난 지점을 나타냅니다. 2번과 5번 장소에서는 6번 소방서가 가장 가깝고, 3번 장소에서는 4번 소방서가 가장 가깝습니다. 이때, 각 장소에 소방차가 도착하기까지 걸리는 시간은 2번 장소에 8분, 5번 장소에 4분, 3번 장소에 4분으로 총 합은 16분이 됩니다.” 예제 설명 발췌 - https://algospot.com/judge/problem/read/FIRETRUCKS풀이법  다익스트라를 돌릴때 시작점을 여러개로 두면 된다코드struct edge {    double cost;    int u;    edge(double c, int u_):cost(c),u(u_){}    edge(){}};struct {    bool operator()(const edge&amp; lhs, const edge&amp; rhs){        return lhs.cost &gt; rhs.cost;    }} op_comp;void dijstra(const map&lt;int, vector&lt;edge&gt;&gt;&amp; source, const vector&lt;int&gt;&amp; input) {    vector&lt;int&gt; dists(source.size(), MAX_VALUE);    vector&lt;int&gt; from(source.size(), -1);    priority_queue&lt;edge, vector&lt;edge&gt;, op_comp&gt; que;        for(int i = 0 ; i &lt; input.size(); i++){        from[i] = i;        edge e(0.00, i);        que.push_back(e);    }        while(!que.empty()) {        edge e1 = que.top(); que.pop();                double cost1 = e1.cost;                for(int i = 0 ; i &lt; source[e1.u].size(); i++) {            edge e2 = source[e1.u][i];            double cost2 = e2.cost;            if(dists[e2.u] &gt; (cost1+cost2)) {                dists[e2.u] = costs1 + costs2;                from[e2.u] = from[e1.u];                que.push(e2);            }        }    }",
        "url": "//2018/03/04/%EC%86%8C%EB%B0%A9%EC%B0%A8.html"
      }
      ,
    
      "2018-03-04-ec-84-a0-ed-83-9d-ec-a0-95-eb-a0-ac-html": {
        "title": "정렬 알고리즘",
        "tags": "알고리즘, 선택정렬, 삽입정렬, 퀵정렬",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "선택정렬 (Selection Sort)  앞에서부터 가장 작은 수를 찾아 전체를 순환해서 위치를 교환한다  비교횟수: N + N-1 + N-2 … N*(N-1)/2  데이터 교환 횟수: N (inplace교환이기 떄문에 요소가 많은 경우에 좋다)  추가 공간 필요 없음  안정성 없음  Worst case: 역순배열삽입정렬 (Insertion Sort)  이미 정렬된 배열에서 효과적임  Worst case: 역순배열 O(N2)  정렬된 배열에 대해서는 O(N)  안정성 있음퀵소트void qsort(const vector&lt;int&gt;&amp; source, int left, int right){    // 포인터 셋팅    int sp = left, ep = right;    // 피봇 셋팅    int pivot = source[(left + right) / 2];    do {        // 피봇보다 작은 값        while (source[sp] &lt; pivot) sp++;        // 피봇보다 큰 값        while (source[ep] &gt; pivot) ep--;        // Swap        if (sp&lt;= ep) {            swap(source[sp], source[ep]);            sp++;            ep--;        }\t} while (sp&lt;= ep);    // 왼쪽 퀵소트    if (left &lt; ep)        quickSort(source, left, ep);            // 오른쪽 퀵소트    if (sp &lt; right)        quickSort(source, sp, right);}        합병정렬 (Merge Sort)  O(N):  Stability: Yes  Space Complexity: O(N) additional space required",
        "url": "//2018/03/04/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC.html"
      }
      ,
    
      "2018-03-04-eb-b9-84-eb-8c-80-ec-b9-ad-ed-83-80-ec-9d-bc-eb-a7-81-html": {
        "title": "비대칭 타일링",
        "tags": "알고리즘, DP, 확률과 경우의 수, 비대칭, 타일링",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  타일링 문제 + 대칭 타일링을 제외하 경우의 수 탐색  대칭 타일링 방법을 전체 경우에서 제외 혹은 비대칭 타일링 방법을 직접 카운트  책 참조코드int asymmetric(int width) {    if(width%2 ==1)        return (tiling(width) - tiling(width/2) + MOD) %MOD;    int ret = }",
        "url": "//2018/03/04/%EB%B9%84%EB%8C%80%EC%B9%AD-%ED%83%80%EC%9D%BC%EB%A7%81.html"
      }
      ,
    
      "2018-03-04-eb-8f-99-ec-a0-84-eb-b0-94-ea-be-b8-ea-b8-b0-html": {
        "title": "Knapsack problem",
        "tags": "알고리즘, DP, 확률과 경우의 수, knapsack",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법 코드int asymmetric(int width) {    if(width%2 ==1)        return (tiling(width) - tiling(width/2) + MOD) %MOD;    int ret = }",
        "url": "//2018/03/04/%EB%8F%99%EC%A0%84%EB%B0%94%EA%BE%B8%EA%B8%B0.html"
      }
      ,
    
      "2018-03-04-eb-8b-ac-ed-8c-bd-ec-9d-b4-ec-9a-b0-eb-ac-bc-html": {
        "title": "우물을 기어 오르는 달팽이",
        "tags": "알고리즘, DP, 확률과 경우의 수, 달팽이",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  깊이가 n인 우물이 있고, 우물의 맨 밑바닥에는 달팽이가 있다  맑은 날에는 2미터를 기어 올라갈 수 있지만, 비가 내리면 1미터를 올라갈 수 있음  비올 확률이 50%일때, m일 안에 달팽이가 우물 끝까지 올라갈 수 있는 확률  점화식 climb(n) = f(n+1,2) + f(n+1,1)코드struct snail {    int n,m;    int vector&lt;map&lt;int,int&gt;&gt;&amp; cache;    int climb(int days, int climbed) {        if(days &gt;= m) return climbed &gt;= n ? 1 : 0;        int&amp; ret = cache[days][climbed];        if(ret != -1) return ret;        return ret = climb(days+1, climbed +2) + climb(days+1, climbed+1);    }}",
        "url": "//2018/03/04/%EB%8B%AC%ED%8C%BD%EC%9D%B4-%EC%9A%B0%EB%AC%BC.html"
      }
      ,
    
      "2018-03-04-eb-82-98-eb-ac-b4-ec-9e-90-eb-a5-b4-ea-b8-b0-html": {
        "title": "나무 자르기",
        "tags": "알고리즘, DP",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제Given a rod of length n inches and an array of prices that contains prices of all pieces of size smaller than n. Determine the maximum value obtainable by cutting up the rod and selling the pieces. For example, if length of the rod is 8 and the values of different pieces are given as following, then the maximum obtainable value is 22 (by cutting in two pieces of lengths 2 and 6)  주어진 제약조건에 따라 나무를 자를때 얻을 수 있는 최대 값  이전의 max 가치와 현재 가격을 빼고 계산했을의 가치를 서로 비교해서 최대 값을 반환한다 - knapsack문제와 동일함    cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}      코드int cutRod(vector&lt;int&gt;&amp; cache, int price[], int n){   if (n &lt;= 0)     return 0;   int max_val = INT_MIN;   int&amp; ret = cache[n];   if(ret != -1)    return ret;    // Recursively cut the rod in different pieces and compare different    // configurations   for (int i = 0; i&lt;n; i++)         ret = max(ret, price[i] + cutRod(price, n-i-1));    return ret;}",
        "url": "//2018/03/04/%EB%82%98%EB%AC%B4%EC%9E%90%EB%A5%B4%EA%B8%B0.html"
      }
      ,
    
      "2018-03-04-ea-b7-b8-eb-9e-98-ed-94-84-html": {
        "title": "그래프",
        "tags": "자료구조, 그래프",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "그래프  무향 그래프  방향 그래프 혹은 유향 그래프  가중치 그래프  단순 그래프  DAG (directed acyclic graph)  철도망  소셜 네트워크 분석  인터넷 전송 속도 계산  한 붓 그리기  외환 거래  할일 목록 정리 - 위상 정렬  퍼즐 - 최소한으로 타일을 움직여 15-퍼즐을 푸는 문제  게임판 덮기  회의실 배정 등등 - 만족성 문제그래프 표현  인접 리스트    vector&lt;list&lt;int&gt;&gt; adjacentstruct edge {  int vertex;  int weight;};vector&lt;edge&gt; adjacent        인접 행렬    vector&lt;vector&lt;bool&gt;&gt; adjacent;        인접 리스트 장단점          메모리를 적게 먹음 O(V+E)      간선 (u,v)가 존재하는지 일일히 확인이 필요              인접 행렬          메모리를 엄청 먹음 O(V2)      간선 확인이 간단함      DFS  인접 리스트의 경우 시간 복잡도는 O(V+E)  인접 행렬의 경우 O(V2)위상정렬  의존성 있는 작업들이 주어질때, 어떤 순서대로 수행해야 하는지 계산해 준다  dependency graph오일러 서킷",
        "url": "//2018/03/04/%EA%B7%B8%EB%9E%98%ED%94%84.html"
      }
      ,
    
      "2018-03-04-ea-b5-ac-ea-b0-84-ed-8a-b8-eb-a6-ac-html": {
        "title": "구간트리 - Segment Tree",
        "tags": "자료구조, 구간트리, Segment Tree, 최대 출현 빈도",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "구간트리  저장된 자료들을 적절치 전처리해 질의들을 빠르게 대답할 수 있게 해줌  그림에서 맨 위가 루트에서 표현하는 구간이고, 양쪽 아래는 루트의 두 자식노드들이 표현하는 구간  구간트리는 일반적으로 꽉찬 이진 트리  배열로 표현을 많이 함 - 원소의 4배 정도로 사이즈를 잡으면 메모리는 낭비되도 전체 요소들을 저장하는데 문제 없음  어떤 구간이 주어지건 답을 찾기 위해 드는 시간은 O(lgn)구간트리의 초기화  현재 구간을 두 개로 나눠 재귀 호출한 뒤, 두 구간의 최소치중 더 작은 값을 선택해 해당 구간의 최소치를 계산한다    struct RMQ {  int n;  vector&lt;int&gt; rangeMin;  RMQ(const vector&lt;int&gt;&amp; array) {      n = array.size();      rangeMin.resize(n*4);      init(array, 0, n-1, 1);  }  int init(const vector&lt;int&gt;&amp; array, int left, int right, int node) {      if(left == right)          return rangeMin[node] = array[left];      int mid = (left+right)/2;      int leftMin = init(array,left, mid, node*2);      int rightMin = init(array,mid+1, right, node*2);      return rangeMin[node] = min(leftMin, rightMin);  }}        모든 노드에 대해 초기화가 필요하기 떄문에 초기화시의 시간복잡도는 O(N)구간트리의 질의 처리  query(left, right, nodeLeft, nodeRight) = node  쿼리 함수 [nodeLeft, nodeRight]와 우리가 최소치를 찾기 원하는 구간 [left, right]의 교집합의 최소 원소를 반환한다  node가 표현하는 구간 [nodeLeft, nodeRight]와 최소치를 찾을 구간 [left, right]의 교집합을 구한 뒤, 그에 따라 서로 다른 값을 반환한다  교집합이 공집합인 경우: 두 구간은 겹치지 않음. 반환값 없음  교집합이 [nodeLeft,nodeRight]인 경우: [left, right]가 표현하는 집합을 완전히 포함한 경우    struct RMQ {  int query(int left, int right, int nodeLeft, int nodeRight, int node) {      if(right &lt; nodeLeft || nodeRight &lt; left)          return INT_MAX;      if(left &lt;= nodeLeft &amp;&amp; nodeRight &lt;= right)          return rangeMin[node];      int mid = (nodeLeft + nodeRight)/2;      return min(          query(left, right, nodeLeft, mid, node*2),           query(left, right, mid+1, nodeRight, node*2));  }}        전체 시간 복잡도는 O(lg n)구간 트리의 갱신  배열의 index 위치의 값이 newValue로 바뀌었다고 할떄의 시간 복잡도 - 위치를 포함하는 구간은 트리에 O(lgn)개 있음. 따라서, O(lgN) 시간에 구간 트리를 갱신할 수 있음  갱신 과정은 query() + init()      int update(int index, int value, int nodeLeft, int nodeRight, int node) {      if(index &lt; nodeLeft || index &lt; left)          return INT_MAX;      if(nodeLeft == nodeRight)          return rangeMin[node] = value;      if(index &lt;= nodeLeft &amp;&amp; nodeRight &lt; index)          return rangeMin[node];      int mid = (nodeLeft + nodeRight)/2;      return min(          query(index, value, nodeLeft, mid, node*2),           query(index, value, mid+1, nodeRight, node*2));  }        정렬된 수열의 특정 구간에서 최대 출현 빈도 계산    정렬된 정수 수열이 주어질때, 주어진 구간의 최대 출현 빈도를 계산하는 문제를 풀어라  A= {0,0,1,1,1,1,2,3,3,3,4} 라면 A{1}부터 A{5} 까지 가장 많이 등장하는 수는 1로 모두 네 번 등장, A[5-A[7] 범위에는 1,2,3이 모두 한번씩 출현 가장 맣이 등장하는 횟수는 1",
        "url": "//2018/03/04/%EA%B5%AC%EA%B0%84%ED%8A%B8%EB%A6%AC.html"
      }
      ,
    
      "2018-03-04-knapsack-problem-html": {
        "title": "Knapsack problem",
        "tags": "알고리즘, DP, 확률과 경우의 수, knapsack",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  배낭에 절박도를 최대화할 수 있는 물건들의 목록들을 계산하는 방법 코드int asymmetric(int width) {    if(width%2 ==1)        return (tiling(width) - tiling(width/2) + MOD) %MOD;    int ret = }",
        "url": "//2018/03/04/knapsack-problem.html"
      }
      ,
    
      "2018-03-04-running-median-html": {
        "title": "변화하는 중간 값 - Running Median",
        "tags": "알고리즘, Media, Online, Priority Queue",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  텅빈 수열에서 시작해서 각 수가 추가될 때마다 중간 값을 계산하는 프로그램을 작성하시오  유사문제: https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/관찰  최대, 최소 prority queue를 사용해서 해결 가능  최대 힙의 크기는 최소 힙의 크기와 같거나 하나 더 크다  최대 힙의 최대 원소는 초소 힙의 최소 원소보다 작거나 크다  수열의 중간 값은 항상 최대 힙의 루트에 있다코드struct runningMedian {    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;    void addNum(int num) {        if(maxHeap.size() == minHead.size())            maxHeap.push(num);        else            minHeap.push(num);                if(!minHeap.empty() &amp;&amp; !maxHeap.empty() &amp;&amp; minHeap.top() &lt; maxHeap.top()) {            int a = maxHeap.top(), b = minHeap.top();            maxHeap.pop(); minHeap.pop();            maxHeap.push(b);            minHeap.push(a);        }    }    int getMedian() {        return maxHeap.top();    }}",
        "url": "//2018/03/04/Running-median.html"
      }
      ,
    
      "2018-03-04-preorder-inorder-eb-a1-9c-postorder-ec-95-8c-ec-95-84-eb-82-b4-ea-b8-b0-html": {
        "title": "트리의 PreOrder, InOrder 순회로 PotOrder 알아내기",
        "tags": "알고리즘, 트리, 순환",
        "date": "March 4, 2018",
        "author": "",
        "category": "",
        "content": "문제  주어진 PreOrder, InOrder 순환 값으로 PostOrder 순환 값을 에측하라  트리를 주어진 순환 값으로 부터 구성하면서 PostOrder 순환을 한다코드vector&lt;int&gt; slice(vector&lt;int&gt;&amp; src, int a, int b) {    return vector&lt;int&gt;(src.begin()+a, src.end()+b);}void postOrder(vector&lt;int&gt;&amp; preOrder, vector&lt;int&gt;&amp; inOrder) {    int length = preOrder.size();    int root = preOrder[0]; // preOrder의 제일 처음에 나오는 값이 루트이다.        int left = find(inOrder.begin(), inOrder.end(), root) - inOrder.begin();    int right = length - left - 1; // 루트 값 제외    postOrder(slice(preOrder, 1, left+1), slice(inOrder, 0, left));    postOrer(slice(preOrder, left+1, length), slice(inOrder, left+1, length));    cout &lt;&lt; root &lt;&lt; ' ';    }",
        "url": "//2018/03/04/PreOrder-InOrder%EB%A1%9C-PostOrder-%EC%95%8C%EC%95%84%EB%82%B4%EA%B8%B0.html"
      }
      ,
    
      "2018-03-03-ed-83-80-ec-9d-bc-eb-a7-81-html": {
        "title": "타일링 방법의 수 세기",
        "tags": "알고리즘, DP, tiling",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "출처  알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률문제설명  2n 크기의 사각형을 21 크기의 타일로 채우는 방법의 수를 계산하는 문제  타일을 길게 붙이거나 (21) 혹은 옆으로 누워서 붙이는 경우 (2n)로 붙이는 경우를 생각해서 계산  즉, f(n) = f(n-1) + f(n-2)const int mod_num = 1000000007;int tiling(const vector&lt;int&gt;&amp; input, int width) {    if(width &lt;=1) return 1;    int &amp; ret = cache[width];    if(ret !=-1) return ret;    return ret = (tiling(input, width-2) + tiling(input, width-1))%mod_num;}",
        "url": "//2018/03/03/%ED%83%80%EC%9D%BC%EB%A7%81.html"
      }
      ,
    
      "2018-03-03-ec-9b-90-ec-a3-bc-ec-9c-a8-ec-99-b8-ec-9a-b0-ea-b8-b0-html": {
        "title": "원주율 외우기",
        "tags": "알고리즘, DP",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "출처  알고리즘 문제 해결 전략 - 문제 8.7관찰  원주율을 몇 만 자리까지 외우기 위해 일반적으로 쓰는 방법은 3~5글자 정도로 끓어서 외운다  주어진 숫자에 대해 최소의 난이도를 구하는 방법을 계산하시오    경우                  예                   난이도모든 숫자가 같을때               ex)333,55555         1숫자가 1씩 증가 혹은 감소         ex)23456,3210        2두개의 숫자가 번갈아 가면서 나타날때  ex)323, 54545       4...      코드  DP를 써서 점화식을 먼저 세운다  F(L) = min(F(L,3), F(L,4), F(L,5))  F(L,3) -&gt; min(F(L,4), F(L,5), F(L,6)) + classify(L,3)  classify하는 부분은 경우에 따라 파싱하면 됨  DP의 점화식에 따른 구현을 눈여겨 보도록 하자int classify(const string&amp; input, int spos, int length) {    /// 문자열을 끓어서 classify 해서 돌려준다}int memorize(const string&amp; input, vector&lt;int&gt;&amp; cache, int begin) {    if(begin == input.size())        return 0;        int&amp; ret = cache[begin];    if(ret != -1)        return ret;    ret = INF;    // 3~5글자 사이로 끓어 읽어서 최소값을 구한다    for(int L = 3 ; L &lt;= 5; ++L) {        if(begin + L &lt;= input.size()) {            ret = min(ret,                     memorize(input, cache, begin+L) + classify(input, begin, L));        }    }    return ret;}",
        "url": "//2018/03/03/%EC%9B%90%EC%A3%BC%EC%9C%A8%EC%99%B8%EC%9A%B0%EA%B8%B0.html"
      }
      ,
    
      "2018-03-03-ec-82-bc-ea-b0-81-ed-98-95-ec-b5-9c-eb-8c-80-ea-b2-bd-eb-a1-9c-ea-b0-9c-ec-88-98-ec-84-b8-ea-b8-b0-html": {
        "title": "삼각형 위의 최대 경로 개수 세기",
        "tags": "알고리즘, DP, tiling",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "출처  알고리즘 문제 해결 전략 - 8.11 경우의 수와 확률문제설명  이전의 문제는 최대 경로의 합을 구했을뿐, 경로 자체는 구하지 않았다  최대 경로는 유일하지 않을 수도 있다  문제를 해결하기 위해 두 개의 다른 동적 계획법 문제를 해결  합을 먼저 구하고, 그 합을 구하는 도중에 만든 캐싱을 통해 패스를 구현struct triangle {    vector&lt;vector&lt;int&gt;&gt; input;    vector&lt;vector&lt;int&gt;&gt; cache;    vector&lt;vector&lt;int&gt;&gt; countCache;        int path(int y, int x) {        if(y == input.size() -1)            return input[y][x];                int&amp; ret = cache[y][x];        if(ret != -1)            return ret;                return ret = max(path(y+1,x), path(y+1,x+1))+input[y][x];    }        int count(int y, int x) {        if(y==input.size()-1)            return 1;                int &amp; ret = countCache[y][x];        if(ret!=-1)            return ret;                if(path(y+1,x+1)&gt;=path(y+1,x))            ret += path(y+1,x+1);        if(path(y+1,x+1)&lt;=path(y+1,x))            ret += path(y+1,x);        return ret;    }}",
        "url": "//2018/03/03/%EC%82%BC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C-%EA%B0%9C%EC%88%98%EC%84%B8%EA%B8%B0.html"
      }
      ,
    
      "2018-03-03-get-max-even-sum-from-tree-html": {
        "title": "Get Max Even Sum From Tree",
        "tags": "",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "문제  output the maximum EVEN sum along any path  ![/assets/img/maxevensum.png]  트리의 각 노드들을 더해서 최대값이자 짝수인 값을 구하기  짝수가 된다는 말에 잘 주목을 해야 할 것 같다  답이 없어서 정확하게 파악은 안되지만…  모든 경로마다의 합을 구해서 정렬을 해서 짝수를 구하는 방법이 있지만, 이건 별로 안좋아할듯  그게 아니면 짝수가 되는 경우를 확인해서 최대 값을 구하는 방법이 있을것 같다  문제가 워낙 간단하게 나와서 정확한 제약조건은 알 길이 없지만, 만약 정할 수 있다면 루트를 거쳐야 한다와 마이너스 값은 허용되지 않음 두가지 경우를 설정하고 싶다  루트를 거쳐야 한다면 루트가 홀수인 경우는 왼쪽이 홀수 아니면 오른쪽이 홀수 값을 리턴해야 한다  루트가 짝수인 경우는 왼쪽, 오른쪽 둘다 홀수 혹은 짝수가 되어야 한다  그리고 post order 방식으로 트리를 순환하고, 노도의 값을 먼저 더해서 노드의 왼쪽 오른쪽 노드의 탐색이 끝난 후에 값을 확인한다#include &lt;iostream&gt;struct node {    int value;    node* left, *right;    node(int n):value(n){}};int oddNodeAdd(node* ptr, int total) {    if(!ptr)        return total;        int left = oddNodeAdd(ptr-&gt;left, total + ptr-&gt;value);    int right = oddNodeAdd(ptr-&gt;right, total + ptr-&gt;value);        int ld = left % 2, rd = right % 2;    if(ld == 1 &amp;&amp; rd ==1)        return max(left, right);        if(ld==1 &amp;&amp; rd==0)        return ld;        if(rd==1 &amp;&amp; ld==0)         return rd;        return total;}int evenNodeAdd(node* ptr, int total) {        if(!ptr)        return 0 ;        int left = evenNodeAdd(ptr-&gt;left, total + ptr-&gt;value);    int right = evenNodeAdd(ptr-&gt;right, total + ptr-&gt;value);        //     int ld = left %2, rd = right%2;        if((ld ==0&amp;&amp;rd ==0)) {        return max(left, right);    }        if(ld==1&amp;&amp;ld==0) {        return rd;    }        if(ld==0&amp;&amp;rd==1) {        return ld;    }    return total;}int getMaxEvenNumber(node* ptr) {        int maxValue = 0 ;    int oddLeft = oddNodeAdd(ptr-&gt;left,0);    int oddRight = oddNodeAdd(ptr-&gt;right, 0);    int evenLeft = evenNodeAdd(ptr-&gt;right,0);    int evenRight = evenNodeAdd(ptr-&gt;right,0);        maxValue = max(oddLeft + oddRight, evenLeft + evenRight);    maxValue = max(maxValue, max(oddLeft+evenRight, evenLeft+oddRight));    maxValue = maxValue + ptr-&gt;value;         return maxValue;}int main() {    node* ptr = new node(10);    ptr-&gt;left = new node(2);    ptr-&gt;left-&gt;left = new node(1);    ptr-&gt;left-&gt;right = new node(101);    ptr-&gt;right = new node(5);    ptr-&gt;right-&gt;right = new node(13);      cout &lt;&lt; getMaxEvenNumber(ptr);}",
        "url": "//2018/03/03/get-max-even-sum-from-tree.html"
      }
      ,
    
      "2018-03-03-shortest-palindrome-html": {
        "title": "KMP 알고리즘",
        "tags": "알고리즘, 문자열, KMP, Panlindrome",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "Shortest Palindrome출처  https://leetcode.com/problems/shortest-palindrome/description/문제  주어진 스티링 S에 대해서 글자들을 앞부분에 더해서 회문으로 만들 수 있다. 이때, 가장 짧은 글자를 더해서 만들 수 있는 회문을 구하라.  Given “aacecaaa”, return “aaacecaaa”.Given “abcd”, return “dcbabcd”.분석  Bruteforce로 할 수 있는 방법:          S를 reverse 해서 reversed 된 스트링의 substring과 S의 서브스트링을 비교한다.      Time complexity: O(N2)      Space complexity: O(N)        string shortestPalindrome(string s){ int n = s.size(); string rev(s); reverse(rev.begin(), rev.end()); int j = 0; for (int i = 0; i &lt; n; i++) {  if (s.substr(0, n - i) == rev.substr(i))      return rev.substr(0, i) + s; } return \"\";}                      KMP 방식을 사용한다          KMP 방식에 따라 Fail function lookup table 을 만들면 얼마만큼의 prefix가 현재까지 매칭되었는지를 알 수 있고 이 값을 사용해서 panlindrome을 만들기 위해 필요한 문자열을 알 수 있게 된다.      입력 S을 reverse한후 ‘#’ 와 함께 원래 입력에 더한다 string input = s + ‘#’ + reverse(s)      ’#’은 원래 값과 reverse된 문자열이 섞이지 않도록 필요              KMP fail_function을 만들어서 surfix와 동일한 prefix의 최장 길이를 구할 수 있고 이 길이를 알면 reverse된 문자열에서 필요한 문자열을 뽑아낼 수 있다```class Solution {  public:  string shortestPalindrome(string input) {        int n = input.length();  string rev(input);  std::reverse(rev.begin(), rev.end());        string source = input + “#” + rev;  int len = source.size();        vector fail_table(len, 0);        for(int pos = 1; pos &lt; len; pos++){      int last_match_pos = fail_table[pos-1];      while(last_match_pos &gt; 0             &amp;&amp; source[pos] != source[last_match_pos])          last_match_pos = fail_table[last_match_pos-1];          if(source[pos] == source[last_match_pos])      ++last_match_pos;          fail_table[pos] = last_match_pos;   }                 return rev.substr(0, n - fail_table[len - 1]) + input;            ```",
        "url": "//2018/03/03/Shortest-Palindrome.html"
      }
      ,
    
      "2018-03-03-kmp-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "KMP 알고리즘",
        "tags": "알고리즘, 문자열, KMP",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "출처  http://www.crocus.co.kr/559  http://jason9319.tistory.com/130KMP 알고리즘(KMP Algorithm)  www.crocus.co.kr  KMP 방식을 요약하면..          패턴의 substring을 만들어서 prefix 와 suffix가 같을때의 최장 길이를 찾는다ex) aba =&gt; 1, aabaa =&gt;2, acdefa =&gt; 1 ..      패턴의 substring 매칭에 대한 테이블을 만든다              void fail_function(const string&amp; input, vector&lt;int&gt;&amp; output) {  output.resize(input.size(),0);    int last_pos = 0;  for(auto pos = 1; pos &lt; input.size(); pos++) {  while(last_pos &gt;0 &amp;&amp; input[pos] != input[last_pos])      last_pos = output[last_pos-1];          if(input[pos] == input[last_pos])      output[pos] = ++last_pos;  }}                      source = aabaabaaaabaabaadaabaabac가 있다고 가정하자.  pattern = aabaabac를 찾으려 한다면 표를 다음과 같이 이용하면 된다.    aabaaba[a]aabaabaadaabaabacaabaaba[c]        비교결과 :: aabaaba까지 같다. 따라서 arr[i]의 7번째 인덱스에서 a와 c가 틀렸으니,aabaaba의 f[6] = 4 따라서 (7-4) = 3인 arr[3]부터 다시 확인한다.    aabaabaa[a]abaabaadaabaabac aabaa[b]ac        비교결과 :: aabaa까지 같다. 따라서 arr[i]의 8번째 인덱스에서 a와 b가 틀렸으니, aabaa의 f[i] = 2 따라서 (8-2) = 6인 arr[6]부터 다시 확인한다.    aabaabaa[a]abaabaadaabaabac　　　 aa[b]aabac        비교결과 :: aa까지 같다. 따라서 arr[i]의 8번째 인덱스에서 a와 b가 틀렸으니, aa의 f[i] = 1 따라서 (8-1) = 7인 arr[7]부터 다시 확인한다.    aabaabaa[a]abaabaadaabaabac　　　 aa[b]aabac        비교결과 :: aa까지 같다. 따라서 arr[i]의 9번째 인덱스에서 a와 b가 틀렸으니, aa의 f[i] = 1 따라서 (9-1) = 8인 arr[8]부터 다시 확인한다.    aabaabaaa[a]baabaadaabaabac　　　  aa[b]aabac        비교결과 :: aabaaba까지 같다. 따라서 arr[i]의 15번째 인덱스에서 a와 c가 틀렸으니, aabaaba의 f[i] = 4 따라서 (15-4) = 11인 arr[11]부터 다시 확인한다.    aabaabaaaabaaba[a]daabaabac　　　　　aabaaba[c]        비교결과 :: aabaa까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 b가 틀렸으니, aabaa의 f[i] = 2 따라서 (16-2) = 14인 arr[14]부터 다시 확인한다.    aabaabaaaabaabaa[d]aabaabac　　　　　　 aabaa[b]ac        비교결과 :: aa까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 b가 틀렸으니, aa의 f[i] = 1 따라서 (16-1) = 15인 arr[15]부터 다시 확인한다.    aabaabaaaabaabaa[d]aabaabac　　　　　　    aa[b]aabac        비교결과 :: a까지 같다. 따라서 arr[i]의 16번째 인덱스에서 d와 a가 틀렸으니, a의 f[i] = 0  따라서 (16-0) = 16인 arr[16]부터 다시 확인한다.    aabaabaaaabaabaa[d]aabaabac　　　　　　　   a[a]baabac        비교결과 :: 같은 것이 없다. 따라서 arr[17]부터 다시 확인한다.    aabaabaaaabaabaad[aabaabac]　　　　　　　      [aabaabac]        비교결과 :: 모두 일치. 정답을 도출한다.( 일치하는 문자열의 시작 인덱스 :: 17, 일차하는 문자열의 개수 :: 1)출처: http://www.crocus.co.kr/559 [Crocus]주의점:  머릿속으로 생각하기는 쉬우나 Fail Function 을 만드는 코드가 생각보다는 코딩하기가 헷갈린다.void kmp(const string&amp; input, const string&amp; pattern, vector&lt;int&gt;&amp; output) {    vector&lt;int&gt; fail_table;    fail_function(pattern, fail_table);       int last_pos = 0 ;    for(auto pos = 0; pos &lt; input.size(); pos++) {        while(last_pos &gt; 0 &amp;&amp; input[pos] != pattern[last_pos])            last_pos = fail_table[last_pos-1];                if(input[pos] == pattern[last_pos]){            if(last_pos == pattern.size() -1) {                output.push_back(pos);                last_pos = fail_table[last_pos-1];            }            else {                last_pos++;            }        }    }}",
        "url": "//2018/03/03/KMP-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "2018-03-03-jis-html": {
        "title": "합친 LIS",
        "tags": "알고리즘, DP",
        "date": "March 3, 2018",
        "author": "",
        "category": "",
        "content": "출처  알고리즘 문제 해결 전랙 1권 8.5문제  두 개의 정수 수열 A와 B에서 각각 길이 0 이상의 증가 부분 수열을 얻은 뒤에 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 함  A와 B가 주어질때 합친 LIS의 길이를 계산하는 프로그램을 작성하시오  이걸 왜 DP로 풀었는지는 의문이다  그냥 합치면 되는거 아닌가?코드const long long NEGINF = numeric_limit&lt;long long&gt;::min();int jlis(vector&lt;vector&lt;int&gt;&gt;&amp; cache,          const vector&lt;int&gt;&amp; A, int pos_a,          const vector&lt;int&gt;&amp; B, int pos_b) {        // -1부터 시작할 수 있기 때문에 인덱스에 +1을 해준다    int&amp; ret = cache[pos_a+1][pos_b+1];    if(ret!= -1) return ret;        ret = 2; // 무조건 두개 이상의 요소가 있기 때문에...    long long a = (pos_a == -1)?NEGINF:A[pos_a];    long long b = (pos_b == -1)?NEGINF:B[pos_b];    long long max_element = max(a,b);        for(int ap = pos_a+1; ap &lt; A.size(); ap++)        if(max_element &lt; A[ap])            ret = max(ret, jlis(cache, A, ap, B, pos_b)+1);        for(int bp = pos_b + 1; bp &lt; B.size(); bp++){        if(max_element &lt; B[bp]){            ret = max(ret, jlis(cache, A, pos_a, B, bp) +1);        }    }    return ret;}",
        "url": "//2018/03/03/JIS.html"
      }
      ,
    
      "2018-03-02-ec-9d-b4-ed-95-ad-ea-b3-84-ec-88-98-ea-b5-ac-ed-95-98-ea-b8-b0-html": {
        "title": "이항계수 구하기 - binominal coefficient",
        "tags": "알고리즘, DP, 이항계수",
        "date": "March 2, 2018",
        "author": "",
        "category": "",
        "content": "이항계수(파스칼의 삼각형) 구하기  파스칼 트리 구하기 문제  파스칼 트리와 이항계수의 관계는 이 블로그를 참조: http://blog.naver.com/PostView.nhn?blogId=vollollov&amp;logNo=220947452823  간략하게 그림만 보면 아래와 같은 관계가 있다 (출처: 위의 블로그)    (n,r)  = (n-1,r-1) + (n-1,r)  이항계수 (n,r)은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수  중복계산되는 항이 많기 때문에 메모이제이션 사용해서 계산량 줄이는 것이 필요코드1int bino(int n, int r) {    if(r==0 || n==r ) return 1;    return bino(n-1,r-1) + bino(n-1,r);}코드2(+memoization)// cache의 초기값은 -1int bino(vector&lt;vector&lt;int&gt;&gt;&amp; cache, int n, int r) {    if(r==0 || n==r) return 1;    if(cache[n][r]!= -1) return cache[n][r];    return cache[n][r] = cache[n-1][r-1] + cache[n][r];}",
        "url": "//2018/03/02/%EC%9D%B4%ED%95%AD%EA%B3%84%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "2018-03-02-ec-99-b8-eb-b0-9c-eb-9b-b0-ea-b8-b0-html": {
        "title": "외발뛰기",
        "tags": "알고리즘, DP",
        "date": "March 2, 2018",
        "author": "",
        "category": "",
        "content": "외발뛰기  게임판의 왼쪽 칸 위에서 오른쪽 칸에 도착하는 하는 것이 가능하는지 파악하는 것이 목적  각 게임판에 있는 숫자만큼 아래나 오른쪽으로 이동 가능  DP를 사용하며, 메모이제이션을 사용해서 문제를 빨리 해결 가능  미로의 끝까지 가는 것을 확인하는 것이 목적이기 때문에, 아래로 바로 내려가거나 오른쪽으로 가는 두 가지 방법중 한가지라도 걸리면, true가 된다                              점화식: f(x, y) = (f(x, y + map[y][x])                     f(x+ map[y][x], y))                    코드bool jump(vector&lt;vector&lt;int&gt;&gt;&amp; map, vector&lt;vector&lt;int&gt;&gt;&amp; cache, int x, int y) {    int width = map[0].size();    int height = map.size();    if (x &gt;= width || y &gt;= height )        return false;        if(x==width=1 &amp;&amp; y == height-1)        return true;    int&amp; val = cache[y][x];    if(val != -1)        return (val==1);        int jumpSize = map[y][x];    return val = (jump(map, cache, x+jumpSize, y) || jump(map,cache, x, y+jumpSize));}",
        "url": "//2018/03/02/%EC%99%B8%EB%B0%9C%EB%9B%B0%EA%B8%B0.html"
      }
      ,
    
      "2018-03-02-ec-99-80-ec-9d-bc-eb-93-9c-ec-b9-b4-eb-93-9c-eb-a7-a4-ec-b9-ad-html": {
        "title": "와일드카드 스트링 매치",
        "tags": "알고리즘, DP, 와일드카드",
        "date": "March 2, 2018",
        "author": "",
        "category": "",
        "content": "와일드카드 스트링 매칭  흔히쓰는 와일드카드 ?, *을 사용해서 문자열이 해당 패턴에 일치하는지 파악한다  예) he?p =&gt; help (O), he?p =&gt; helpp (X), hp =&gt; help (O), hp =&gt; helpp (O)  DP를 사용해서 문제를 풀 수 있다관찰  문자열와 패턴을 각각 W, S라고 하자.  만약 현재 위치 w,s에 대해 W[w] != S[s]이면 해당 없음  W[w] == S[s] 이거나 W[w] == ‘?’이면 매칭이고, 다음 글자 를 계속 조사  매칭하지 않아도 W[w] == ‘*‘이면 이후의 글자들을 전부 조사해서 매칭이 되는지의 여부를 파악한다  W의 w+1과 S의 s+1 이후의 값들을 확인해서 하나라도 참이면 답은 참이 된다  시간복잡도는 O(n2)점화식    bool matchWords(vector&lt;vector&lt;int&gt;&gt;&amp; cache,         const string&amp; W,        int w,         const string&amp; S,        int s) {            int&amp; ret = cache[w][s];            if(ret != -1)                return ret;                        while(s &lt; S.size() &amp;&amp; w &lt; W.size() &amp;&amp;                    (W[w] == '?' || W[w] == S[s]) {                        ++w;                        ++s;                    }                        if(w==W.size()) return ret = (s==S.size());            if(W[w] == '*') {                if(matchWords(cache, W, w+1, S, s) ||                    (s &lt; S.size() &amp;&amp; matchWords(cache, W, w, S, s+1))                    return ret = 1;            }            return ret = 0;        }",
        "url": "//2018/03/02/%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A7%A4%EC%B9%AD.html"
      }
      ,
    
      "2018-03-02-ec-82-bc-ea-b0-81-ed-98-95-ec-97-90-ec-84-9c-ec-9d-98-ec-b5-9c-eb-8c-80-ea-b2-bd-eb-a1-9c-html": {
        "title": "삼각형에서의 최대 경로",
        "tags": "알고리즘, DP",
        "date": "March 2, 2018",
        "author": "",
        "category": "",
        "content": "삼각형에서의 최대 경로61 23 7 49 4 1 72 7 5 9 4  맨 위의 숫자에서 시작해서 한 번에 한 칸씩 아래(바로 아래(y+1), 오른쪽 아래(x+1, y+1)로 내려가서 맨 아래줄에 도달하는 경로중 숫자의 합을 최대화 하는 경로는?  경로가 여러개가 있기 때문에 메모이제이션이 쉽지 않음  f(x,y,sum) = max(f(x+1,y, sum + triangle[y][x]), f(x,y+1, sum + triangle[y][x]))      int maxSum(const vector&lt;vector&lt;int&gt;&gt;&amp; input,              vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; cache,              int x,              int y, int sum) {                  if(y == n-1)                      return sum + input[y][x];                                      int&amp; val = cache[y][x][sum];                  if(val != -1)                      return val;                                      sum += input[y][x];                  return max(                      maxSum(input, cache, x+1, y+1, sum),                      maxSum(input, cache, x, y+1, sum)                  );              }        재귀함수에 sum을 더해줄 필요가 없다. sum이 있건 없건 부분 경로의 최대 값이 중요하다  Optimal Substructure  f(x,y) = max(f(x+1,y), f(x,y+1)) + triangle[y][x];      int maxSum(const vector&lt;vector&lt;int&gt;&gt;&amp; input,              vector&lt;vector&lt;int&gt;&gt;&amp; cache,              int x,              int y) {                  int&amp; ret = cache[y][x];                  if(ret != -1)                      return ret;                  if(y==n-1)                      return input[y][x];                                      return ret = max(                                  maxSum(input, cache, x+1, y+1),                                  maxSum(input, cache, x, y+1)                  );              }        시간복잡도 - 부분 문제에서는 O(N2), 전체문제에서는 상수 시간이 추가되기 때문에 결국 O(N2)",
        "url": "//2018/03/02/%EC%82%BC%EA%B0%81%ED%98%95%EC%97%90%EC%84%9C%EC%9D%98%EC%B5%9C%EB%8C%80%EA%B2%BD%EB%A1%9C.html"
      }
      ,
    
      "2018-03-01-longest-common-substring-html": {
        "title": "최장 공통 부분 문자열 - Longest Common Substring",
        "tags": "알고리즘, DP, Longest Common Substring, LCS",
        "date": "March 1, 2018",
        "author": "",
        "category": "",
        "content": "설명  Longest Common Subsequence 문제와 거의 유사하지만 약간 다른 문제  아까의 로직과 비슷하다, 다만 문자열의 경우는 subsequence가 아니기 때문에 중간에 어긋나면 리셋이 가능하다  DP로 풀 수 있는 가장 일반적인 솔루션  두 개의 문자열에 대한 테이블을 만든다  LCSubstr(X, Y, m, n) = LCSubstr(X, Y, m-1, n-1) + 1 if X[m-1] = Y[n-1] 0  Otherwise (if X[m-1] != Y[n-1])  LCSubStr(X, Y, m, n)  = Max(LCSubstr(X, Y, i, j)) where 1 &lt;= i &lt;= m and 1 &lt;= j &lt;= n  시간 복잡도는 문자열 A가 N개의 글자로 이루어진 문자열이고 문자열 B가 M개의 글자로 이루어진 문자열이라면, NM 번의 검사를 통해 테이블을 만들어야 하기 때문에 결국 O(NM)코드  DP 풀이      for(int i = 0 ; i &lt; A.size(); i++) {      for(int j = 0; j &lt; B.size(); j++) {          if(A[i] == B[j]) {              table[i][j] = table[i-1][j-1] + 1;              result = max(result, table[i][j]);          }          else {              table[i][j] = 0 ;          }      }  }        Suffix Array로 문제해결          ",
        "url": "//2018/03/01/longest-common-substring.html"
      }
      ,
    
      "2018-03-01-longest-common-sequence-html": {
        "title": "최장 공통 부분 수열 - Longest Common Subsequence",
        "tags": "알고리즘, DP, Longest Common Subsequence",
        "date": "March 1, 2018",
        "author": "",
        "category": "",
        "content": "설명  두 문자열이 주어졌을 때, 두 문자열에 모두 포함된 가장 긴 공통 부분 문자열을 찾는 프로그램을 작성하시오.  두 문자열 ABRACADABRA와 ECADADABRBCRDARA의 공통 부분 문자열은 CA, CADA, ADABR, 빈 문자열 등이 있다. 이 중에서 가장 긴 공통 부분 문자열은 ADABR이며, 길이는 5이다. 또, 두 문자열이 UPWJCIRUCAXIIRGL와 SBQNYBSBZDFNEV인 경우에는 가장 긴 공통 부분 문자열은 빈 문자열이다.  두 개의 문자열에 대한 테이블을 만든다  LCS(Xi, Yj) = 0 if xi = 0 or yj = 0  LCS(Xi, Yj) = LCS(Xi-1, Yj-1) +  1 if xi = yj  LCS(Xi, Yj) = longest(LCS(Xi-1, Yj),LCS(Xi, Yj-1))  if xi != yj코드int LCS(const string&amp; input, const string&amp; compare) {        if(input.size() == 0 || compare.size() == 0)        return 0 ;        vector&lt;vector&lt;int&gt;&gt; table;    for(int i = 0 ; i &lt; input.size(); i++){        vector&lt;int&gt; v(compare.size(), 0);        table.push_back(v);    }        if(input[0] == compare[0])        table[0][0] = 1;        for(int x = 1; x &lt; input.size(); x++) {        for(int y = 1; y &lt; compare.size(); y++){            if(input[x] == compare[y]) {                table[x][y] = table[x-1][y-1] + 1;            }            else {                table[x][y] = max(table[x][y-1], table[x-1][y]);            }        }    }    int ret = table[input.size()-1][compare.size()-1];     return ret;}  아래의 설명은 http://hsp1116.tistory.com/37 에서 가져옴  Ai == Bj일 때 LCS(i,j) = LCS(i-1,j-1) + 1 이기 떄문에 LCS(i,j) &gt; LCS(i-1,j-1)  LCX(i,j) = max(LCS(i-1,j),LCS(i,j-1))의 경우:  Ai != Bj일 지라도, LCS(i,j) = max(LCS(i-1,j),LCS(i,j-1))를 통해 LCS(i-1,j-1) + 1가 도출 될 수 있다.  LCS(i-1,j), LCS(i,j-1)이 둘 다 LCS(i,j)보다 작고 LCS(i-1,j-1)이 LCS(i,j)보다 작은 경우가 Ai==Bj일 때이다.  LCS[i][j] &gt; LCS[i-1][j-1] &amp;&amp; LCS[i][j] &gt; LCS[i][j-1] &amp;&amp; LCS[i][j] &gt; LCS[i-1][j])를 조건으로 코드를 구현하면 된다.void backTracking(int m, int n){    if(m==0 || n ==0) return;    if(cache[m][n] &amp;gt; cache[m-1][n-1] &amp;amp;&amp;amp; cache[m][n] &amp;gt; cache[m][n-1] &amp;amp;&amp;amp; cache[m][n] &amp;gt; cache[m-1][n]){        &lt;span style=\"color: rgb(174, 174, 174);\" data-evernote-id=\"407\" class=\"js-evernote-checked\"&gt;//문자열 인덱스는 캐시 인덱스보다 1씩 더 작다. &lt;/span&gt;        output = input[n-1] + output;        backTracking(m-1, n-1);    }else if(cache[m][n] &amp;gt; cache[m-1][n] &amp;amp;&amp;amp; cache[m][n] == cache[m][n-1]){        backTracking(m, n-1);    }else{          backTracking(m-1, n);    }}참고 및 추가 설명  출처: https://www.acmicpc.net/problem/5582  추가 설명: https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%9E%A5%EA%B3%B5%ED%86%B5%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4",
        "url": "//2018/03/01/longest-common-sequence.html"
      }
      ,
    
      "2018-03-01-find-max-sum-sequence-html": {
        "title": "정수 배열에서 가장 큰 이어지는 원소들의 합을 구하라 - 시간복잡도는 O(n)",
        "tags": "알고리즘, 회문, Longest Increasing Subsequence",
        "date": "March 1, 2018",
        "author": "",
        "category": "",
        "content": "  출처: 매일프로그래밍 #1  Longest increasing subsequence  이 문제는 최대 합을 구하기 위해 원소들을 계속 더해 나갈때 음의 원소가 나왔을 때 그 원소를 계속 더하는게 맞는지 아닌지를 판단하는 것이 중요하다  아래에서 currentMax는 원소들을 계속 더해 가면서 현재 인덱스에서의 최대 값을 의미한다  maxMax 값은 이제까지 나왔던 값들 중에서 최대 값을 의미하다. 즉, 중간에 음수 값이 나왔을때 이 값이 일시적으로 currentMax보다 커질수 있다  쉽지만, 헤맬수 있는 문제..Input: [-1, 3, -1, 5]Output: 7 ( 3 + (-1) + 5 )Input: [-5, -3, -1]Output: -1 ( -1 )Input: [2, 4, -2, -3, 8]Output: 9 ( 2 + 4 + (-2) + (-3) + 8 )int findMaxSum(const vector&lt;int&gt;&amp; input) {    int current_sum = 0;    int max_sum = 0 ;    for(int i = 0 ; i &lt; input.size(); i++) {        current_sum = max(current_sum + input[i], input[i]);        max_sum = max(max_sum, current_sum);    }    return max_sum;}",
        "url": "//2018/03/01/find-max-sum-sequence.html"
      }
      ,
    
      "2018-02-28-longest-panlindrome-string-html": {
        "title": "정렬된 LinkedList를 BST로 변환하기",
        "tags": "알고리즘, 회문, panlindrome",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "  Given a string, find the longest substring which is palindrome. For example, if the given string is “forgeeksskeegfor”, the output should be “geeksskeeg”.  워낙 유명한 문제라.. 문제에 대한 설명은 생략한다  brute-force, dynamic programming 아니면 매 인덱스마다 좌우로 찾는 이 방법이 있다.  ’’’int getMaxLengthOfPanlindrome(const string&amp; input, int low, int high, int maxLength, int&amp; start) {    int len = input.size();while (low &gt;= 0 &amp;&amp; high &lt; len &amp;&amp; input[low] == input[high]){    if (high - low + 1 &gt; maxLength)    {        start = low;        maxLength = high - low + 1;        cout &lt;&lt; low &lt;&lt; \", \" &lt;&lt; input[low] &lt;&lt; \", \" &lt;&lt; high &lt;&lt; \", \" &lt;&lt; input[high] &lt;&lt; endl;    }    --low;    ++high;}  return maxLength;   }int findLongestPanlindromeString(const string&amp; input) {int maxLength = 1;  // The result (length of LPS)int start = 0;  for (int i = 1; i &lt; input.size(); ++i){    // 회문이 짝수인 경우    int low = i - 1;    int high = i;    maxLength = getMaxLengthOfPanlindrome(input, low, high, maxLength, start);     // 회문이 홀수인 경우    low = i - 1;    high = i + 1;    maxLength = getMaxLengthOfPanlindrome(input, low, high,maxLength, start);} cout &lt;&lt; \"Longest palindrome substring is: \" &lt;&lt; endl;cout &lt;&lt; input.substr(start, start + maxLength - 1); return maxLength;     } '''",
        "url": "//2018/02/28/longest-panlindrome-string.html"
      }
      ,
    
      "2018-02-28-longest-increasing-sequence-html": {
        "title": "최장 증가 수열 - Longest increasing subsequence",
        "tags": "알고리즘, DP, LIS",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "  최장 증가 수열 문제 - DP로 풀거나 lower_bound 사용해서 풀 수 있음  DP의 경우는 O(N^2), lower_bound의 경우는 O(NlogN)int getMaxLIS(const vector&lt;int&gt;&amp; input, int pos, int value, int current) {    if(pos &gt;= input.size())        return current;           if(input[pos] &gt; value) {        return getMaxLIS(input, pos+1, input[pos], current+1);    }    else {        return getMaxLIS(input, pos+2, value, current);    }}int findMaxLIS(const vector&lt;int&gt;&amp; input) {    int maxLIS = 0 ;    for(int i = 0; i &lt; input.size(); i++) {        maxLIS = max(maxLIS, getMaxLIS(input,i+1,input[i],1));    }    return maxLIS;}int main() {    vector&lt;int&gt; input = {10,20,40,25,20,50,30,70,85};    cout &lt;&lt; \"maxLIS: \" &lt;&lt; findMaxLIS(input) &lt;&lt; endl;}  Lower Bound 사용 - O(NLogN)  하나씩 숫자를 스트리밍하면서 low bound를 구하면 최장으로 증가할 수 있는 수열의 최대 길이 값을 구할 수 있다  알고리즘 출처: http://jason9319.tistory.com/113void get_lower_bound(vector&lt;int&gt;&amp; input, int val) {    if (input.back() &lt; val) {        input.push_back(val);    }    else {        auto it = lower_bound(input.begin(), input.end(), val);        *it = val;    }} int LIS(const vector&lt;int&gt;&amp; input) {    vector&lt;int&gt; min_bound;    const int MAX = 0x7fffffff;    min_bound.push_back(MAX);        for(int i = 0; i &lt; input.size(); i++ ) {        get_lower_bound(min_bound, input[i]);    }        return min_bound.size();}",
        "url": "//2018/02/28/longest-increasing-sequence.html"
      }
      ,
    
      "2018-02-28-linkedlist-to-bst-html": {
        "title": "정렬된 LinkedList를 BST로 변환하기",
        "tags": "그래프, 알고리즘, BST, Linked List",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "  정렬된 linkedlist를 binary search 방식으로 BST로 변환한다  0~n개의 노드가 있을떄 중간 노드(n/2)의 값을 구하고 왼쪽 노드는 왼쪽 중간 노드를 구해서 (0~n/2의 중간값 n/4) 값을 설정한다  오른쪽 노드의 값은 n/2에서 n까지의 중간값을 구해서 설정하는 방식으로 재귀적으로 호출해서 BST를 완성한다.’’’tnode* llist_to_bst(lnode* head, lnode* tail) {if(head == nullptr)    return nullptr;lnode* fast_ptr = head;lnode* slow_ptr = slow;while(fast_ptr != nullptr &amp;&amp; fast_ptr != tail) {    fast_ptr = fast_ptr-&gt;next;    slow_ptr = slow_ptr-&gt;next;    if(fast_ptr!= nullptr &amp;&amp; fast_ptr != tail)        fast_ptr = fast_ptr-&gt;next;}tnode * ptr = new tnode(slow_ptr-&gt;value);ptr-&gt;left = llist_to_bst(head, slow_ptr);ptr-&gt;right = llist_to_bst(slow_ptr-&gt;next, tail);return ptr; } '''",
        "url": "//2018/02/28/linkedlist-to-bst.html"
      }
      ,
    
      "2018-02-28-find-biggest-bst-html": {
        "title": "아주 큰 트리에서 가장 큰 BST 찾기",
        "tags": "트리, 알고리즘, BST",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "문제  You are given a very large binary tree, return the root node of the largest BST in the given tree분석  왼쪽, 오른쪽 순환하면서 BST 조건에 맞는 노드를 찾기 시작한다  현재 노드 값이 알려진 Max 값보다 크게 되면 BST가 아니다  현재 노드의 값이 알려진 Min 값보다 작다면 BST가 아니다  왼쪽 노드가 BST이고, 오른쪽 노드가 BST라면 두 개의 값을 합치고 +1 해서 현재까지 알려진 최대 BST보다 큰 트리인지 비교한다  만약 크다면 현재 노드 값을 헤드값으로 기억한다코드int find_biggest_bst(    node* ptr,     int&amp; min, int &amp;max,     int&amp; total_nodes,     node*&amp; head) {      if(!ptr)        return 0;        int left = find_biggest_bst(ptr, min, max, total_nodes, head);    int current_min = (left ==0)?ptr-&gt;value: min;    if((left==-1) || (left != 0 &amp;&amp; ptr-&gt;value &gt; max)) {        return -1;    }        int right = find_biggest_bst(ptr, min, max, total_nodes, head);    int current_max = (right == 0)? ptr-&gt;value:max;    if(right == -1 || (right != 0 &amp;&amp; ptr-&gt;value &lt; min)) {        return -1;    }        int total = left + right + 1;    current_min = min;    current_max = max;    if(total_nodes &lt; total) {        total_ndoes = total;    }    return total;}",
        "url": "//2018/02/28/find-biggest-bst.html"
      }
      ,
    
      "2018-02-28-convert-bst-to-double-linked-list-html": {
        "title": "Convert Bst To Double Linked List",
        "tags": "",
        "date": "February 28, 2018",
        "author": "",
        "category": "",
        "content": "layout: posttitle: BST를 Double Linked List로 변환하기tags: [그래프,알고리즘, BST, Linked List]—  왼쪽 노드를 계속 순환해서 최소값이 될때까지 순환한다  최소값이 되면, 그 노드의 값을 헤드값으로 저장하고 부모노드 및 오른쪽 노드를 계속 추가해서 리스트를 만든다  노드를 추가할때 현재 노드의 이전 노드 값이 prev값과 동일한지 확인할 필요가 있다.’’’struct node {    node(int n): value(n){}    int value;    node* left, * right;};void insert_before(node* prev, node* current) {    node* temp = current-&gt;left;    if(prev) {        cout « “prev - n: “ « prev-&gt;value « endl;        prev-&gt;right = current;        prev-&gt;left = temp;    }if(temp &amp;&amp; temp != prev) {    cout &lt;&lt; \"temp-n: \" &lt;&lt; temp-&gt;value &lt;&lt; endl;    temp-&gt;right = prev;    }cout &lt;&lt; \"after prev, temp\" &lt;&lt; endl;current-&gt;left = prev; }void bst_to_ddl(node* ptr, node&amp; prev, node&amp; head, int&amp; min) {    if(!ptr)        return;bst_to_ddl(ptr-&gt;left, prev, head, min);insert_before(prev, ptr);prev = ptr;if(ptr-&gt;value &lt; min) {    cout &lt;&lt; \"min: \" &lt;&lt; ptr-&gt;value &lt;&lt; endl;    min = ptr-&gt;value;    head = ptr;}bst_to_ddl(ptr-&gt;right, prev, head, min); }int main() {    node* root_ptr = new node(4);    root_ptr-&gt;left = new node(2);    root_ptr-&gt;right = new node(5);    root_ptr-&gt;left-&gt;right = new node(3);    root_ptr-&gt;left-&gt;left = new node(1);int min = 100;node* prev_ptr = nullptr;node* head_ptr;bst_to_ddl(root_ptr, prev_ptr, head_ptr, min);node* current_ptr = head_ptr;while(current_ptr) {    cout &lt;&lt; current_ptr-&gt;value &lt;&lt; endl;    current_ptr = current_ptr-&gt;right;} } '''",
        "url": "//2018/02/28/convert-bst-to-double-linked-list.html"
      }
      ,
    
      "2018-02-26-ed-81-ac-eb-a3-a8-ec-8a-a4-ec-b9-bc-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "크루스칼 알고리즘",
        "tags": "그래프, 알고리즘, 크루스칼",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  크루스칼 알고리즘  edge의 cost별로 정렬한다  하나씩 빼서 cycle을 만드는지 확인한다  사이클을 만들지 않는 edge들만 뽑아서 리턴한다  상당히 간단하다  사이클을 만드는데 사용하는 disjoined_set 알고리즘은 간단하지만 효과적이다  시간 복잡도는 모든 edge에 대해 정렬하기 때문에 O(ElogE)  disjoined set의 경우는 시간복잡도가 ELogE보다 작기 때문에, 정렬하는데 드는 시간이 driving forceusing namespace std;struct edge {    int u,v,cost;    edge(int u1, int v1, int c):u(u1), v(v1), cost(c) {}    bool operator &lt; (const edge&amp; e) {        return cost &lt; e.cost;    }};struct disjoined_set {    map&lt;int,int&gt; parent;    void init(vector&lt;edge&gt;&amp; edges) {        for(auto e : edges) {            if(!parent.count(e.u))                parent.insert(make_pair(e.u, e.u));                        if(!parent.count(e.v))                parent.insert(make_pair(e.v, e.v));        }    }        int find_parent(int u) {        if(parent[u] == u)            return u;        cout &lt;&lt; \"u: \" &lt;&lt; u &lt;&lt; \", u_parent: \" &lt;&lt; parent[u] &lt;&lt; endl;                return parent[u] = find_parent(parent[u]);    }        bool same_set(int u, int v) {        cout &lt;&lt; \"before same_set\" &lt;&lt; endl;        if(find_parent(u) == find_parent(v))            return true;                cout &lt;&lt; \"false\" &lt;&lt;endl;        return false;    }        void merge(int u, int v){        int u_parent = find_parent(u);        int v_parent = find_parent(v);        cout &lt;&lt; \"u_parent: \" &lt;&lt; u_parent &lt;&lt; \", v_parent: \" &lt;&lt; v_parent &lt;&lt; endl;        if(u_parent == v_parent)            return;                parent[v_parent] = u_parent;                }};vector&lt;edge&gt; kruskal(vector&lt;edge&gt;&amp; input) {    sort(input.begin(), input.end());    vector&lt;edge&gt; output;    disjoined_set ds;    ds.init(input);        for(auto e : input) {        cout &lt;&lt; \"edge u: \" &lt;&lt; e.u &lt;&lt; \", v: \" &lt;&lt; e.v &lt;&lt; \", cost: \" &lt;&lt; e.cost &lt;&lt;endl;        if(!ds.same_set(e.u, e.v)) {            cout &lt;&lt; \"ds.same_set \" &lt;&lt; endl;            output.push_back(e);            ds.merge(e.u, e.v);        }    }    cout &lt;&lt; \"output\" &lt;&lt; endl;    return output;}int main() {    edge e1(1,3,4);    edge e2(1,2,5);    edge e3(2,3,2);    edge e4(2,4,7);    edge e5(3,4,6);    edge e6(3,5,11);    edge e7(4,5,3);    edge e8(4,6,8);    edge e9(5,6,8);    vector&lt;edge&gt; edges = {e1,e2,e3,e4,e5,e6,e7,e8,e9};    vector&lt;edge&gt; output = kruskal(edges);        for(edge e : output)        cout &lt;&lt; \"edge u: \" &lt;&lt; e.u &lt;&lt; \", v: \" &lt;&lt; e.v &lt;&lt; \", cost: \" &lt;&lt; e.cost &lt;&lt;endl;}",
        "url": "//2018/02/26/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "2018-02-26-ec-82-ac-ec-9d-b4-ed-81-b4-ec-b2-b4-ed-81-ac-html": {
        "title": "사이클 체크",
        "tags": "그래프, 알고리즘, 사이클",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  사이클 확인 알고지름  DFS 방식을 활용해서 사이클이 있는지 확인한다  현재 순환중이면 상태를 VISTING으로 변경해서 순환이 끝나지 않았음에도 불구하고 다시 체크하러 오는지 확인하다  현재 노드들을 순환중인데도 불구하고 다시 확인하러 오면 사이클이 있음  시간 복잡도는 O(E+V)using namespace std;enum STATUS {  NOT_VISITED,    VISITING,    VISITED};bool hasCycle(map&lt;int,vector&lt;int&gt;&gt;&amp; input,             map&lt;int, int&gt;&amp; visited,             int here) {    if(visited[here] == VISITING){        cout &lt;&lt; here &lt;&lt; \" confirmed visiting\" &lt;&lt; endl;        return true;    }    else if(visited[here] == VISITED)        return false;        visited[here] = VISITING;    cout &lt;&lt; here &lt;&lt; \" visiting \" &lt;&lt; endl;        for(int there : input[here]) {        cout &lt;&lt; there &lt;&lt; \" checking \" &lt;&lt; endl;        if(hasCycle(input, visited, there))            return true;    }    visited[here] = VISITED;    return false;}void process(const vector&lt;vector&lt;int&gt;&gt;&amp; input, map&lt;int, vector&lt;int&gt;&gt;&amp; output){    for(auto entry : input) {        int u = entry[0];        int v = entry[1];                    if(!output.count(u)) {            vector&lt;int&gt; vec = { v };            output.insert(make_pair(u, vec));        }        else {            output[u].push_back(v);        }    }}int main() {    vector&lt;vector&lt;int&gt;&gt; input = {        {1,2},        {1,3},        {2,3},        {3,4},        {2,4},        {3,5},        {4,5},        {4,6},        {5,6},    };        map&lt;int, vector&lt;int&gt;&gt; source;    process(input, source);    map&lt;int,int&gt; visited;    for(auto kvp : source)        visited.insert(make_pair(kvp.first,0));    bool cycle = hasCycle(source, visited, 1);    cout &lt;&lt; \"cycle: \" &lt;&lt; cycle &lt;&lt; endl;}",
        "url": "//2018/02/26/%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%B2%B4%ED%81%AC.html"
      }
      ,
    
      "2018-02-26-permutation-html": {
        "title": "Permutation",
        "tags": "",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/26/permutation.html"
      }
      ,
    
      "2018-02-26-max-diameter-of-tree-html": {
        "title": "트리의 최장 직경 구하기",
        "tags": "트리, 알고리즘",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  어느 한 노드가 있을 경우 최장 직경은..  왼쪽에서 가장 큰 height와 오른쪽에서 가장 큰 height에 1을 더한 값과  왼쪽에서의 가능 큰 직경, 오른쪽에서의 가장 큰 직경  이 세 값 중에서 가장 큰 값을 고르면 된다struct node {    node* left, *right};int height(node* ptr) {    if(!ptr)        return 0;        int lh = height(ptr-&gt;left);    int rh = height(ptr-&gt;right);    return 1 + max(lh, rh);}int diameter(node* ptr) {    if(!ptr)        return 0;        int lh = height(ptr-&gt;left);    int rh = height(ptr-&gt;right);    int ld = diameter(ptr-&gt;left);    int rd = diameter(ptr-&gt;right);    return max(1+lh+rh, max(ld,rd));}",
        "url": "//2018/02/26/max-diameter-of-tree.html"
      }
      ,
    
      "2018-02-26-find-largest-bst-html": {
        "title": "Find Largest Bst",
        "tags": "",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/26/find-largest-bst.html"
      }
      ,
    
      "2018-02-26-connect-all-the-nodes-html": {
        "title": "섬의 개수 세기",
        "tags": "그래프, 알고리즘",
        "date": "February 26, 2018",
        "author": "",
        "category": "",
        "content": "  next 노드를 구하기 위해서는 부모노드의 next를 타고 가서 왼쪽 노드가 있는지 확인한다 없으면 오른쪽 노드  왼쪽 오른쪽 자식 노드가 존재하지 않으면 또 부모 노드의 옆의 노드로 가서 위와 동일하게 반복한다  횡으로 탐색이 끝나면, 다음 자식 노드로 내려가기 위해서 왼쪽 자식 노드 혹은 오른쪽 자식 노드의 값을 사용해서 동일하게 옆의 노드를 체크한다struct node {    int n;    node* left, * right, * next;};node* findNext(node* ptr) {    node* next = ptr-&gt;next;    while(next) {        if(next-&gt;left)            return next-&gt;left;        if(next-&gt;right)            return next-&gt;right;        next  = next-&gt;next;    }    return next;};void connectNext(node* ptr) {        node* level_ptr = ptr;        while(level_ptr) {        node * current = level_ptr;             while(current) {            if(current-&gt;left)                current-&gt;left-&gt;next = (!current-&gt;right) ? current-&gt;right: findNext(current);                        if(current-&gt;right)                current-&gt;right = findNext(current);            current = current-&gt;next;        }                    if(level_ptr-&gt;left)            level_ptr = level_ptr-&gt;left;        else        if(level_ptr-&gt;right)            level_ptr = level_ptr-&gt;right;    }}",
        "url": "//2018/02/26/connect-all-the-nodes.html"
      }
      ,
    
      "2018-02-25-number-of-islands-html": {
        "title": "Number Of Islands",
        "tags": "",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "",
        "url": "//2018/02/25/number-of-islands.html"
      }
      ,
    
      "2018-02-25-longest-substring-without-repeating-characters-html": {
        "title": "Longest substring without repeating characters",
        "tags": "LST, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "##출처:  https://leetcode.com/problems/longest-substring-without-repeating-characters/description/문제  Given a string, find the length of the longest substring without repeating characters.    Examples:Given \"abcabcbb\", the answer is \"abc\", which the length is 3.Given \"bbbbb\", the answer is \"b\", with the length of 1.Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.      분석  Sliding Window 방식을 사용한다  큐에 캐릭터를 집어 넣는다  반복된 문자가 나오면, 지금까지 쌓아놓았던 문자의 수를 기억한다  큐에서 문자를 계속 poping한다. 새로 집어 넣으려고 하는 문자와 동일한 문자가 나올때까지  반복되는 문자가 발견되면, 다시 카운트를 시작한다  O(N)으로 해결 가능코드class Solution {public:    int popAndCount(char c, vector&amp; bvec, queue&amp; cqueue) {        auto size = cqueue.size();        while(!cqueue.empty() &amp;&amp; cqueue.front() != c) {            bvec[cqueue.front()] = false;            cqueue.pop();        }        if(cqueue.front() == c) {            bvec[c] = false;            cqueue.pop();        }                  return size;            }        int lengthOfLongestSubstring(string input) {        queue cqueue;        vector bvec(128);        auto maxValue = 0 ;                 for(auto i = 0; i &lt; input.length(); i++) {               char c = input[i];                if(bvec[c]) {                auto count = popAndCount(c, bvec, cqueue);                maxValue = std::max(maxValue, count);            }            cqueue.push(c);            bvec[c] = true;        }                if(!cqueue.empty()) {            auto count = 0;            while(!cqueue.empty()) {                count++;                cqueue.pop();            }            maxValue = std::max(maxValue, count);        }        return maxValue;        }};",
        "url": "//2018/02/25/longest-substring-without-repeating-characters.html"
      }
      ,
    
      "2018-02-25-light-is-failing-to-the-left-side-of-tree-html": {
        "title": "빛은 트리의 왼쪽에 떨어진다",
        "tags": "트리, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "Light is falling on a tree from left side you have to find all the nodes on which this light will fall.  일반적인 트리 문제  왼쪽에서만 보이는 트리들을 필터링해서 보여주면 된다코드struct node {    int value;    node* left, *right;};void filter_nodes_from_leftside(node* ptr, const int level, int&amp; max_level) {    if(!ptr)        return;        if(level &gt; max_level) {        max_level = level;        cout &lt;&lt; ptr-&gt;value &lt;&lt; endl;    }    filter_nodes_from_leftside(ptr-&gt;left, level+1, max_level);    filter_nodes_from_leftside(ptr-&gt;right, level+1, max_level);}",
        "url": "//2018/02/25/light-is-failing-to-the-left-side-of-tree.html"
      }
      ,
    
      "2018-02-25-disjoined-set-html": {
        "title": "디스조인트 셋",
        "tags": "그래프, 디스조인트",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "출처  https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0  https://ratsgo.github.io/data%20structure&amp;algorithm/2017/11/12/disjointset/  http://js1jj2sk3.tistory.com/m/category/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Disjoint-set%20%EB%94%94%EC%8A%A4%EC%A1%B0%EC%9D%B8%ED%8A%B8-%EC%85%8B  http://bowbowbow.tistory.com/26설명  서로 중복되지 않은 부분집합들로 나누워진 정보들을 저장  set A, set B: B가 A의 모든 요소를 포함하는 경우: A = subset of B, B = superset of A  set A, set B: A와 B가 공유하는 원소가 없다면: A와 B는 mutually disjoint  임의의 셋을 분할(partition): 서로 중복되는 원소가 없도록 셋을 나눔  분할된 셋들을 합치면 원래의 셋으로 복원연산  make-set(x): 초기화 연산, x를 유일한 요소로 하는 셋을 만듬  union(x,y): x가 속한 셋과 y가 속한 셋을 합침  셋들을 합칠때에는 대표값들을 서로 연결해 줌  set A (3) (3&lt;-4), set B (1) (1&lt;-2)  untion(A,B)(3) (2-&gt;1-&gt;3&lt;-4)  find(x): x가 속한 셋의 대표값(루트노드 값)을 반환find 연산  구조에 따라서 여러가지 방법으로 find가 가능하지만..  재귀적인 방식으로 find 연산을 구현한 방식을 표현하면..      선형시간으로 탐색이 가능    function find(x)  if x.parent != x:      x.parent = Find(x.parent)  return x.parent      union 연산      두 셋의 대표들을 찾아 연결해 주면 된다.    function union(x,y):  xRoot = find(x)  yRoot = find(y)  yRoot.parent = xRoot      일반적인 set collection과의 비교  일반적인 stl에서 구현된 set의 경우 BST 구조를 가져서, 일반적인 연산의 경우 log의 시간을 가진다  disjoint set은 노드에 parent 하나만 추가해서 선형적인 시간에 값을 가져올 수 있음struct disjoined_set {    map&lt;char, char&gt; parent;    void init_set(vector&lt;char&gt; vertext) {        for(auto ch : vertext)            parent.insert(make_pair(ch,ch));    }        char find_parent(char ch) {        if(find_parent(ch) == ch)            return ch;                return parent[ch] = find_parent(parent[ch]);    }        bool same_set(char c1, char c2) {        char c1_parent = find_parent(c1);        char c2_parent = find_parent(c2);                if(c1_parent == c2_parent)            return true;        return false;    }        void merge(char c1, char c2) {        if(same_set(c1, c2))            return;                parent[c2_parent] = c1_parent;    }}",
        "url": "//2018/02/25/disjoined-set.html"
      }
      ,
    
      "2018-02-25-diameter-of-tree-html": {
        "title": "Diameter of tree - 트리의 직경",
        "tags": "트리, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "  트리의 직경은 가장 크게 떨어진 두 개의 노드 사이에 있는 노드들의 개수를 의미한다  트리의 직경을 구할때 트리의 height와의 비교도 필요하다코드int height(node* ptr) {    if(!ptr)        return 0;    return 1 + max(height(ptr-&gt;left), height(ptr-&gt;right));}int diameter(node *ptr) {        if(!ptr)        return 0;        int lheight = height(ptr-&gt;left);    int rheight = height(ptr-&gt;right);    int left = diameter(ptr-&gt;left);    int right = diameter(ptr-&gt;right);        return max(lheight + rheight +1, max(left, right));   }",
        "url": "//2018/02/25/diameter-of-tree.html"
      }
      ,
    
      "2018-02-25-lca-html": {
        "title": "Lowest Common Ancestor",
        "tags": "트리, LCA, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "출처  http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/분석  트리를 DFS 방식으로 재귀호출한다  비교 해야 하는 두 값이 n1,n2라고 가정한다  만약 노드의 값이 n1, n2와 동일하면, 그 노드가 LCA  왼쪽과 오른쪽 노드의 값을 재귀호출로 검사  왼쪽 트리에서 n1의 값이 발견되고, 오른쪽에 n2가 발견되면 그 서브트리의 루트가 LCA  왼쪽에서 n1,n2 값이 발견되면 왼쪽을 검사해서 LCA 리턴코드class node {public:      int val;      node* left_ptr;      node* right_ptr:};node* findLCA(node* tree_ptr, int n1, int n2){      if(tree_ptr-&gt;val == n1 || tree_ptr-&gt;val == n2)          return tree_ptr;      node* left_ptr = findLCA(tree_ptr-&gt;left, n1,n2);      node* right_ptr = findLCA(tree_ptr-&gt;right,n1,n2);      if(left_ptr &amp;&amp; right_ptr)         return tree_ptr;      return (left_ptr!=NULL)?left_ptr:right_ptr;}",
        "url": "//2018/02/25/LCA.html"
      }
      ,
    
      "2018-02-25-clone-a-tree-with-random-pointer-html": {
        "title": "Clone a binary tree with random pointers",
        "tags": "트리, 알고리즘",
        "date": "February 25, 2018",
        "author": "",
        "category": "",
        "content": "  Clone a Binary Tree with Random Pointers  Given a Binary Tree where every node has following structure.  The random pointer points to any random node of the binary tree and can even point to NULL, clone the given binary tree.관찰  쉽게 할 수 있는 방법은 map을 사용하는 방식  노드 하나를 추가할때 마다 이전 노드의 키와 새로 생성한 노드의 주소를 맵에 추가한다  트리 생성이 완료되면 한바퀴 트리를 순회하면서 메모리 주소를 맵에서 꺼내서 업데이트 한다코드  맵 혹은 해시 테이블을 사용할 경우는 특별한 부분이 없다  트리를 순회하면서 노드들을 복사하고, 기존에 있던 노드 값과 그에 대응되어 생긴 노드의 주소 값을 맵에 넣는다  복사가 끝나면, 다시 한 번 순회해서 random 포인터를 새로 생긴 노드 값으로 업데이트 한다struct node{    int value;    node* left, *right, *random;    node(int n, node* rand):value(n),random(rand){}};void copy_node(node* ptr_src,                node* ptr_dst,                map&lt;node*, node*&gt;&amp; mem_table) {    if(ptr_src == nullptr)        return;        if(ptr_src-&gt;left) {        ptr_dst-&gt;left = new node(ptr_src-&gt;left-&gt;value, ptr_src-&gt;left-&gt;random);        mem_table.insert(make_pair(ptr_src-&gt;left, ptr_dst-&gt;left));        copy_node(ptr_src-&gt;left, ptr_dst-&gt;left, mem_table);    }        if(ptr_src-&gt;right) {        ptr_dst-&gt;right = new node(ptr_src-&gt;right-&gt;value, ptr_src-&gt;right-&gt;random);        mem_table.insert(make_pair(ptr_src-&gt;right, ptr_dst-&gt;right));        copy_node(ptr_src-&gt;right, ptr_dst-&gt;right, mem_table);    }}void update_random_ptr(node* ptr_src, node* ptr_dst, map&lt;node*,node*&gt;&amp; mem_table) {        if(ptr_src == nullptr)        return;        if(ptr_src-&gt;left)        update_random_ptr(ptr_src-&gt;left,  ptr_dst-&gt;left, mem_table);        if(ptr_dst-&gt;random)        ptr_dst-&gt;random = mem_table[ptr_src-&gt;random];        if(ptr_src-&gt;right)        update_random_ptr(ptr_src-&gt;right, ptr_dst-&gt;right, mem_table);}node* clone_tree(node* ptr) {        node* clone_ptr = new node(ptr-&gt;value, ptr-&gt;random);    node* pos_ptr = ptr;    map&lt;node*, node*&gt; mem_table;    copy_node(ptr, clone_ptr, mem_table);    update_random_ptr(ptr, clone_ptr, mem_table);    return clone_ptr;    }",
        "url": "//2018/02/25/Clone-A-Tree-With-Random-Pointer.html"
      }
      ,
    
      "2018-02-24-ed-94-84-eb-a6-bc-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "프림 알고리즘",
        "tags": "알고리즘, 프림, 그래프, 최소거리",
        "date": "February 24, 2018",
        "author": "",
        "category": "",
        "content": "  최소 신장 트리를 구하는데 사용한다  정점을 선택하고 DST와 약간은 유사하게 인접한 정점들의 최소 값을 구해서 트리에 추가한다  minimum priority queue에 인접한 vertex와 cost 정보를 넣는다  최소 cost를 가지는 vertex 정보를 뽑아온다  이미 방문했는지 확인하다  방문 안했으면 인접한 노드들을 queue에 다시 집어 넣는다  최소 값 기준으로 계속 값을 가져와서 스패닝 트리를 만든다  이때 시간 복잡도는 인접 해렬, 검색의 경우는 V^2  이진 힙 및 인접리스트 O((V+E)logV)=ElogV코드struct edge {    int cost, vertex;    edge(int v, int c):vertex(v), cost(c){} };struct less_comp {    bool operator()(const edge&amp; e1, const edge&amp; e2) {        return e1.cost &gt; e2.cost;    }};vector&lt;edge&gt; prim(map&lt;int, vector&lt;edge&gt;&gt;&amp; input, int start) {    priority_queue&lt;edge, vector&lt;edge&gt;, less_comp&gt; que;    map&lt;int, bool&gt; selected;        edge s(start,0);    que.push(s);        vector&lt;edge&gt; output;    int cost = 0 ;        while(!que.empty()) {        edge adjacent = que.top(); que.pop();                int here = adjacent.vertex;                if(selected[here]) {            continue;        }                selected[here] = true;                output.push_back(adjacent);                for(auto e : input[here]) {            que.push(e);        }    }    return output;}void process(const vector&lt;vector&lt;int&gt;&gt;&amp; input, map&lt;int, vector&lt;edge&gt;&gt;&amp; output){    for(auto entry : input) {        int u = entry[0];        int v = entry[1];        int c = entry[2];        edge e1(v,c);                    if(!output.count(u)) {            vector&lt;edge&gt; vec = { e1 };            output.insert(make_pair(u, vec));        }        else {            output[u].push_back(e1);        }    }}int main() {    vector&lt;vector&lt;int&gt;&gt; input = {        {1,2,5},        {2,1,5},        {1,3,4},        {3,1,4},        {2,3,2},        {3,2,2},        {3,4,6},        {4,3,6},        {2,4,7},        {4,2,7},        {3,5,11},        {5,3,11},        {4,5,3},        {5,4,3},        {4,6,8},        {6,4,8},        {5,6,8},        {6,5,8}    };        map&lt;int, vector&lt;edge&gt;&gt; output;    process(input, output);    vector&lt;edge&gt; result = prim(output,1);        for(auto e : result)        cout &lt;&lt; \"v: \" &lt;&lt; e.vertex &lt;&lt; \", cost: \" &lt;&lt; e.cost &lt;&lt; endl;}",
        "url": "//2018/02/24/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "2018-02-24-eb-8b-a4-ec-9d-b5-ec-8a-a4-ed-8a-b8-eb-9d-bc-html": {
        "title": "다익스트라 알고리즘",
        "tags": "알고리즘, 다익스트라, 그래프, 최소거리",
        "date": "February 24, 2018",
        "author": "",
        "category": "",
        "content": "  처음 vertex에서 시작한다  정점에 인접한 정점들과 거리를 우선순위 큐에 넣는다  거리순으로 오름차순 정렬해서 기존에 알려진 최소거리와 비교한다  만약 기존에 알려진 최소거리보다 작으면 기존의 최소거리를 업데이트한다  목적지에 도착할때까지 계속 반복한다#include &lt;iostream&gt;struct adjacent {    int v, cost;    adjacent(int v1, int c):v(v1),cost(c){}    bool operator&lt;(const adjacent&amp; adj) {        return cost &lt; adj.cost;    }};struct less_comp_functor{    bool operator()(const adjacent&amp; lhs, const adjacent&amp; rhs) {        return lhs.cost &gt; rhs.cost;    }};int get_or_default(map&lt;int, int&gt;&amp; dists, int v) {    const int INF = 0x7fffffff;        if(!dists.count(v))        dists.insert(make_pair(v,INF));        return dists[v];   }map&lt;int,int&gt; djkstra(map&lt;int, vector&lt;adjacent&gt;&gt;&amp; input, int start) {    map&lt;int,int&gt; dists;    priority_queue&lt;adjacent, vector&lt;adjacent&gt;, less_comp_functor&gt; que;    adjacent adj(start,0);    que.push(adj);        while(!que.empty()) {                adjacent adj = que.top(); que.pop();        int cost = adj.cost;        int v = adj.v;                cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; \", cost: \" &lt;&lt; cost &lt;&lt; endl;                if(get_or_default(dists,v) &gt; cost)            dists[v] = cost;                for(auto a : input[v]) {            int there = a.v;            int new_cost = dists[v] + a.cost;                    if(get_or_default(dists, there) &gt; new_cost){                dists[there] = new_cost;                a.cost = new_cost;                que.push(a);            }                    }    }    return dists;    }int main() {    vector&lt;adjacent&gt; vec1 = {adjacent(2,10), adjacent(3,30), adjacent(4,15)};    vector&lt;adjacent&gt; vec2 = {adjacent(3,5), adjacent(6,20)};    vector&lt;adjacent&gt; vec3 = {adjacent(5,20)};    vector&lt;adjacent&gt; vec4 = {adjacent(6,20)};    vector&lt;adjacent&gt; vec5 = {adjacent(6,5)};    vector&lt;adjacent&gt; vec6 = {adjacent(4,20)};        map&lt;int, vector&lt;adjacent&gt;&gt; input = {        {1,vec1},        {4,vec2},        {2,vec3},        {5,vec4},        {3,vec5},        {6,vec6}             };        auto output = djkstra(input,1);        for(auto o : output) {        cout &lt;&lt; o.first &lt;&lt; \", \" &lt;&lt; o.second &lt;&lt; endl;    }    }",
        "url": "//2018/02/24/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC.html"
      }
      ,
    
      "2018-02-17-median-value-of-bst-html": {
        "title": "median valud of BST",
        "tags": "알고리즘, 다익스트라, 그래프, 최소거리",
        "date": "February 17, 2018",
        "author": "",
        "category": "",
        "content": "문제Given a Binary Search Tree, find median of it. If no. of nodes are even: then median = ((n/2th node + (n+1)/2th node) /2 If no. of nodes are odd : then median = (n+1)th node. For example, median of below BST is 12. 분석  O(N)으로 풀기 위해서는 정상적으로 트리를 순환하는 방식을 사용해야 한다  Median 값을 찾기 위해서는 현재 몇번째 노드를 순환하는지를 알아야 한다  현재 순환한 노드 값이 중간 값인지를 파악하기 위해서는 전체 노드의 수를 알아야 한다  후위 혹은 전위로 순환하면서 방문한 노드이 수를 파악한다  노드의 수가 전체 노드의 중간이며 Median 값을 구한다코드  현재 방문하고 있는 노드의 수를 잘 세는 것이 필요하다class node { public:     node(int n):val(n) {}     int val;     node* left;     node* right;  };int count(node* ptr) {     return (!ptr)?0:1 + count(ptr-&gt;left) + count(ptr-&gt;right);  }int median(node* ptr, int total, int&amp; pos) {    if(!ptr)        return 0;    int right = median(ptr-&gt;right, total, pos);    pos++;    if(pos == total/2 &amp;&amp; total%2 == 0)         return (ptr-&gt;val + ptr-&gt;right-&gt;val)/2;    if(pos == (total/2+1) &amp;&amp; total%2==1)        return ptr-&gt;val;    int left = median(ptr-&gt;left, total, pos);    return right + left;}int main() {     node* root = new node(20);    root-&gt;right = new node(22);    root-&gt;left = new node(8);    root-&gt;left-&gt;left = new node(4);    root-&gt;left-&gt;right = new node(12);    root-&gt;left-&gt;right-&gt;left = new node(10);    root-&gt;left-&gt;right-&gt;right = new node(14);    int pos = 0;    int c = count(root);    int m = median(root, c, pos);    cout &lt;&lt; \"count: \" &lt;&lt; c &lt;&lt; \", \" &lt;&lt; c/2 &lt;&lt; \", m: \" &lt;&lt; m &lt;&lt; endl;}",
        "url": "//2018/02/17/median-value-of-bst.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.7.1/lunr.min.js"></script>
<script src="/assets/js/search.js"></script>
</section>
</article>

    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
